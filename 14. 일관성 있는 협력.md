# 일관성 있는 협력

- 잘 설계된 애플리케이션은 이해하기 쉽고, 수정이 용이하며, 재사용 가능한 협력의 모임이다.
- 객체지향 설계의 목표는 적절한 책임을 수행하는 객체들의 협력을 기반으로 결합도가 낮고 재사용  
  가능한 코드 구조를 찬조하는 것.
- 객체지향 패러다임의 장점은 설계를 "재사용"할 수 있다는 것이다.
  - 재사용을 위해서는 객체들의 협력 방식을 일관성 있게 만들어야 한다.

- 가능하면 유사한 기능을 구현하기 위해 유사한 협력 패턴을 사용하라.
  - 특정한 문제를 유사한 방법으로 해결  
    = 문제를 이해하는 것만으로도 코드의 구조를 예상할 수 있게 된다.


## 01. 핸드폰 과금 시스템 변경하기
![클래스 구조](https://user-images.githubusercontent.com/98109708/154270076-b5dc4115-e70c-4c1b-8c0f-c1ffca3aa4df.jpg)

## 02. 설계에 일관성 부여하기

일관성 있는 설계를 만드는 조언  
1. 다양한 설계 경험을 익혀라.
2. 널리 알려진 디자인 패턴을 학습하고 변경이라는 문맥 안에서 디자인 패턴을 적용해 보라.
 - 디자인 패턴은 특정한 변경에 대해 일관성 있는 설계를 만들 수 있는 경험 법칙을 모아놓을  
   일종의 설계 템플릿.

---
- 협력을 일관성 있게 만들기 위한 기본 지침
  - 변하는 개념을 변하지 않는 개념으로 분리하라.
  - 변하는 개념을 캡슐화 하라.
  
- 코드에서 새로운 요구사항이 있을 때마다 바뀌는 부분이 있다면 분리.
  - 바뀌는 부분을 캡슐화
  - 나중에 바뀌지 않는 부분에는 영향을 미치지 않은 채로 그 부분만 고치거나 확장할 수 있다.

```java
public class ReservationAgency {
    public Reservation reserve(Screening screening, Customer customer, int audienceCount) {
        for(DiscountCondition condition : movie.getDiscountConditions()) {
            if(condition.getType() == DiscountConfitionType.REFIOD) {
                // 기간 조건인 경우
            } else  {
                // 회차 조건인 경우
            }
        }

        if(discountable) {
            switch (movie.getMovieType()) {
                case AMOUNT_DISCOUNT:
                    // 금액 할인 정책인 경우
                case PERCENT_DISCOUNT:
                    // 비율 할인 정책인 경우
                case NONE_DISCOUNT:
                    // 할인 정책이 없는 경우
            }
        } else {
            // 할인 적용이 불가능한 경우
        }
    }
}
```
- 위 코드는 조건들이 추가 시 소스 수정이 계속 발생
- 정차지향 프로그램에서 변경을 처리하는 전통적인 방법 = 조건문의 분기를 추가하거나 개별 분기 로직을 수정하는 것.
- 객체지향은 조금 다른 접근방법을 취한다.
  - 객체지향에서 변경을 다루는 전통적인 방법은 조건 로직을 "객체 사이의 이동"으로 바꾸는 것이다.  
    ```java
    public class Movie {
        private DiscountPolicy discountPolicy;
    
        public Money calculateMovieFee(Screening screening) {
            return fee.minus(discountPolicy.calculateDiscountAmount(screening));
        }
    }
    ```  
    ![역할과 타입계층 구현](https://user-images.githubusercontent.com/98109708/154272461-5c4dd168-977b-446e-9813-fee281c63dc0.jpg)
    - Movie는 현재 할인 정책의 종류를 확인하지 않음.
    - 단순히 현재 할인 정책을 나타내는 discountPolicy에 메시지를 전송할 뿐.
    - 할인 정책 종류를 체크하던 조건문이 discountPolicy로의 "객체 이동"으로 대체된 것 !
  - 다형성은 조건 로직을 객체 사이의 이동으로 바꾸기 위해 객체지향이 제공하는 설계 기법이다. ✔
    - 할인 금액을 계산하는 구체적인 방법은 메시지를 수신하는 discountPolicy의 구체적인 타입에 따라 결정된다.

- 큰 메소드 안에 뭉쳐있던 조건 로직들을 변경의 압력에 맞춰 작은 클래스들로 분리하고 나면 인스턴스들 사이의  
  협력 패턴에 일관성을 부여하기가 더 쉬워진다.
  - 유사한 행동을 수행하는 작은 클래스들이 자연스럽게 "역할"이라는 추상화로 묶이게 되고 
  - 역할 사이에서 이뤄지는 "협력 방식"이 전체 설계의 일관성을 유지할 수 있게 이끌어주기 때문
- 위 설계는 새로운 할인 정책과 할인 조건을 추가하기도 용이하다.

- 협력을 일관성 있게 만들기 위해 따라야 하는 지침  
1.변하는 개념을 변하지 않는 개념으로부터 분리하라.  
2.변하는 개념을 캡슐화 하라.
  - 핵심은 훌륭한 추상화를 찾아 추상화에 의존하도록 만드는 것
  - 추상화에 대한 의존은 결합도를 낮추고 결과적으로 대체 가능한 역할로 구성된 협력을 설계할 수 있게 해준다.
  - 선택하는 추상화의 품질이 캡슐화의 품질을 결정한다. ✔

- 변경에 초점을 맞추고 캡슐화의 관점에서 설계를 바라보면 일관성 있는 협력 패턴을 얻을 수 있다. ✔
  - 디자인 패턴은, 이 같은 접근법을 통해 얻을 수 있는 훌륭한 설계에 대한 경험의 산물이다.

---
캡슐화 다시 살펴보기
- 캡슐화는 데이터 은닉이 아니다! 그 이상이다.
- 캡슐화란 단순히 데이터를 감추는 것이 아니다.
- 소프트웨어 안에서 변할 수 있는 모든 "개념"을 감추는 것이다.  
  ![캡슐화 종류](https://user-images.githubusercontent.com/98109708/154275764-5fe986dc-05bc-4690-8bb4-c76831395dcb.jpg)
  - 객체 캡슐화 = 합성을 의미
  - 서브타입 캡슐화 : 다형성의 기반이 됨

- 코드 수정으로 인한 파급 효과를 제어할 수 있는 모든 기법이 캡슐화의 일종
- 데이터/메소드 캡슐화 : 개별 객체에 대한 변경을 관리하기 위해 사용
- 객체/서브타입 캡슐화 : 협력에 참여하는 객체들의 관계에 대한 변경을 관리하기 위해 사용

- 협력을 가장 일관성 있게 만드는 방법  
  : 서브타입 캡슐화와 객체 캡슐화의 조합
  - 변하는 부분을 분리해서 타입 계층을 만든다.
    - 변하는 부분들의 공통적인 행동을 추상 클래스나 인터페이스로 추상화 한 후 변하는 부분들이 상속, 구현하게 한다.
    - 변하는 부분은 변하지 않는 부분의 서브타입이 된다.
  - 변하지 않는 부분의 일부로 타입 계층을 합성한다.
    - 위에 구현한 타입 계층을 변하지 않는 부분에 합성한다.
    - 변하지 않는 부분은 변하는 부분의 구체적인 종류에 대해 알지 못하게 될 것.
 
 - 여기까지의 예시는 한 가지 방법일 뿐! 변경의 이유에 따라 캡슐화 할 수 있는 다양한 방법이 있다.
 
 ## 03. 일관성 있는 기본 정책 구현하기
 
1.변경 분리하기
 - 변하는 개념과 변하지 않는 개념을 분리

2.변경 캡슐화 하기
 - 변하는 부분을 분리하고 변하는 부분의 공통점을 추상화 한다.
   - 변하는 부분들은 추상화된 공통점의 서브타입이 된다.
 - 변하지 않는 부분이 오직 이 추상화에만 의존하도록 관계를 제한한다.

3.협력 패턴 설계하기
 - 분리 -> 변하는 부분 추상화  
   그 후 변하지 않는 부분만을 이용해 객체 사이의 협력을 이야기 할 수 있다.
 - 추상화 만으로 구성한 협력은 추상화를 구체적인 사례로 대체함으로써 다양한 상황으로 확장할 수 있다.  
   --> 재사용 가능한 협력 패턴이 된다.
 - 책임을 전문가 객체에 할당한다.

4.추상화 수준에서 협력 패턴 구현하기
 - 변하지 않는 요소와 추상적인 요소로 전체적인 협력 구조를 설명할 수 있다.
 - 변하는 것은 추상화 뒤에 캡슐화 되어 숨겨져 있기 때문에 전체적인 협력구조에 영향을 미치지 않는다.

5.구체적인 협력 구현하기
 - 추상화된 인터페이스를 실체화 하는 클래스를 구현한다.
 - 변경을 캡슐화해서 협력을 일광성 있게 만들면 얻는 장점
   - 변하는 부분을 변하지 않는 부분으로부터 분리했기 때문에 변하지 않는 부분 재사용 가능
   - 새로운 기능 추가를 위해 오직 변하는 부분만 구현하면 됨
   - 코드의 재사용성이 향상
   - 기능을 추가할 때 따라야 하는 구조 강제화  
     --> 기능 추가, 변경 시 설계의 일관성이 무너지지 않는다. (확장 포인트 강제)
     
 - 유사한 기능에 대해 유사한 협력 패턴을 적용하는 것?  
   개념적 무결성 ( = 일관성 In 객체지향 시스템)을 유지할 수 있는 가작 효과적인 방법
   - 협력을 설계하고 있다면 항상 기존의 협력 패턴을 따를 수 없는지 고민하라.

6.협력 패턴에 맞추기
 - 협력 구조않에 넣을 수 없는 경우 또 다른 협력 패턴을 적용하지 말고 기존 협력에 최대한 맞춰라.
   - 설계를 약간 비틀어 이상한 구조를 낳더라도 전체적으로 일관성을 유지할 수 있는 설계를 선택하는것이 좋다.
 - 개념적 무결성을 무너뜨리는 것보다 약간의 부조화를 수용하는 편이 더 낫다.

> 지속적으로 개선하라  
> 협력은 고정된 것이 아니다. 만약 현재의 협력 패턴이 새로운 요구사항을 수용하지 못한다면  
> 변경을 수용할 수 있는 협력 패턴을 향해 리팩토링 하라.  
> 중요한 것은 현재의 서계에 맹목적으로 일관성을 맞추는 것이 아니라 달라지는 변경의 방향에 맞춰  
> 지속적으로 코드를 개선하려는 의지다.
 