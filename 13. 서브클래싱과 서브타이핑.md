# 서브클래싱과 서브타이핑

- 상속의 두 가지 목적
  - 타입 계층 구현 ✔  
   : 부모는 자식의 일반화 개념, 자식은 부모의 특수화 계념
  - 코드 재사용

- 상속은 코드 재사용을 편하게 하지만, 재사용 목적으로 상속을 사용하면 부모와 자식 클래스가 강하게 결합됨(비추천)
- 상속의 가치는 동일한 메시지에 대해 서로 다르게 행동할 수 있는 다형적인 객체를 구현하기 위해서  
  객체의 행동을 기반으로 타입 계층을 구성하는 것 ✔


## 01. 타입

1.개념 관점의 타입
  - 사물을 분류하기 위한 틀
  - 심볼(타입 이름), 내연(타입에 속하는 객체들이 공유하는 속성/행동의 집합),  
   외연(타입에 속하는 객체들의 집합)으로 구성됨

2.프로그래밍 언어 관점의 타입
  - 연속적인 비트에 의미와 제약을 부여하기 위함
  - 비트 묶음에 의미를 부여하기 위해 정희된 제약과 규칙
  - 동일한 오퍼레이션을 적용할 수 있는 인스턴스들의 집합
    - 타입에 따라 적용 가능한 오퍼레이션(연산자) 종류를 정의
    - 타입에 따라 오퍼레이션이 가지는 의미를 정의 (int와 String에서 + 연산자는 다르게 동작)

3.객체지향 패러다임 관점의 타입
  - 오퍼레이션 : 객체가 수신할 수 있는 메시지  
    --> 객체지향 프로그래밍에서 타입을 정의하는 것 = 객체가 수신할 수 있는 메시지 종류를 정의하는 것
  - 객체가 수신할 수 있는 메시지 집합 : "퍼블릭 인터페이스" ✔
  - 객체지향에서는 객체가 수신할 수 있는 "메시지"를 기준으로 타입을 분류하기 때문에 동일한 퍼블릭 인터페이스를  
    가지는 객체들은 동일한 타입으로 분류할 수 있다.
    - 객체에게 중요한 것은 속성이 아니라 행동.

> 객체의 퍼블릭 인터페이스가 객체의 타입을 결정한다.  
> 따라서 동일한 퍼블릭 인터페이스를 제공하는 객체들은 동일한 타입으로 분류된다.  
> 객체의 타입을 결정하는 것은 내부의 속성이 아닌, 객체가 외부에 제공하는 행동이다.


## 02. 타입 계층

- 타입 사이의 포함관계
  - 포함하는 타입 : 일반화 된 의미 
  - 포합되는 타입 : 특수화된 의미  
    (일반화) 프로그래밍 언어 > 객체지향 언어 | 절차적 언어 (특수화)

- 내연 관점에서의  
  일반화 : 타입의 정의를 보편적이고 추상적으로 만드는 과정  
  특수화 : 타입의 정의를 구체적이고 문맥 종속적으로 만드는 과정

- 외연 관점에서의  
  일반타입의 인스턴스 집합 : 특수한 타입의 인스턴스 집합을 포함하는 슈퍼셋  
  특수타입의 인스턴스 집합 : 일반적인 타입의 인스턴스 집합에 포함된 서브셋

- 객체의 타입을 결정하는 것은 "퍼블릭 인터페이스"
- 객체지향 관점에서  
  슈퍼타입 : 서브타입이 정의한 퍼블릭 인터페이스를 일반화시켜 상대적으로 범용적이고 넓은 의미로 정의 한 것  
  서브타입 : 슈퍼타입이 정의한 퍼블릭 인터페이스를 특수화시켜 상대적으로 구체적이고 좁은 의미로 정의 한 것


## 03. 서브클래싱과 서브타이핑

- 객체지향 프로그래밍 언어에서 타입을 구현하는 방법? 클래스를 이용  
  타입 계층을 구현하는 방법? 상속을 이용

- 상속의 올바른 용도는 "타입계층을 구현하는 것" ✔

- 상속의 조건 (둘 다 만족해야 한다.)
  - is-a 관계
  - 행동 호환성 ✔

- is-a 관계
  - 어휘적인 정의로는 상속을 적용하면 안된다.  
    ex. 펭귄은 새다 / 새는 날 수 있다 / 펭귄은 날 수 있다(?)
  - 어휘적 정의가 아닌 기대되는 행동에 따라 타입 계층을 구성해야 한다.
  - 타입 계층의 의미는 "행동"이라는 문맥에 따라 달라 질 수 있다.
  - 따라서 슈퍼타입과 서브타입 관계에서는 is-a 보다 행동 호환성이 더 중요

- 행동 호환성
  - 타입의 이름 사이에 개념적으로 어떤 연관성이 있다고 하더라도 행동에 연관성이 없다면 is-a 관계를 사용할 수 없다.
  - 두 타입 사이에 행동이 호환될 경우에만 타입 계층으로 묶어야 한다.  
    ex. 새에 [날다] 라는 행동이 없다면, 새의 서브클래스로 펭귄이 들어갈 수 있다.
  - 행동 호환 여부를 판단하는 기준 ? 클라리언트의 관점 ✔
 - 클라이언트가 두 타입이 동일하게 행동할 것이라고 기대한다면 두 타입을 타입 계층으로 묶을 수 있다.

- 클라이언트의 기대에 따라 계층 분리 하기
  - 상속 계층 분리  
    ![KakaoTalk_20220211_215807954](https://user-images.githubusercontent.com/98109708/153595690-587258f5-3e25-4cdc-9317-8aae82a6f7d2.jpg)
  - 인터페이스 분리  
    ![KakaoTalk_20220211_215807954_01](https://user-images.githubusercontent.com/98109708/153595699-16fb29af-ac90-402b-a7ed-1a81455fa770.jpg)
    - 만약 Penguin에서 bird의 속성을 사용해야 한다면? Bird 상속은 NO!!  
      코드 재사용을 위한 상속은 하지말자.
    - 합성을 사용해 해결한다.
  - 인터페이스 분리 원칙 (Interface Segregation Principle, ISP)  
    : 인터페이스를 클라이언트 기대에 따라 분리함으로써 변경에 의해 영향을 제어하는 설계원칙

- 자연어에 현혹되지 말고 요규사항 속에서 클라이언트가 기대하는 행동에 집중하라.
- 클래스의 이름 사이에 연관성은 의미 없다.  
  두 클래스 사이에 행동이 호환되지 않는다면 올바른 타입 계층이 아니기 때문에 상속을 사용해서는 안 된다.

- 서브클래싱과 서브타이핑  
  : 상속의 목적 1.코드 재사용 / 2.타입 계층의 특별한 이름
  - 기준 : 상속을 사용하는 목적
  - 서브클래싱(subclassing) : 다른 클래스 코드를 재사용 목적으로 상속을 사용하는 경우  
    부모 클래스의 행동이 호환되지 않음. 자식 클래스의 인스턴스가 부모 클래스 인스턴스 대체 불가  
    구현상속, 클래스 상속
  - 서브타이핑(subtyping) : 타입 계층을 구성하기 위해 상속을 사용하는 경우  
    인터페이스 상속
  - 서브타이핑 관계가 유지되지 위해서는 서브타입이 슈퍼타입이 하는 모든 행동을 동일하게 할 수 있어야 한다.  
    --> 행동 호환성
  - 부모 클래스를 새로운 자식 클래스로 대체하더라도 시스템이 문제없이 동작할 것을 보장  
    --> 대체 가능성
  - 추상 클래스를 상속한다는 것은 단순한 코드 재사용을 위한 상속이 아니라 추상클래스가 정의하고 있는 인터페이스를  
    상속하겠다는 의미


## 04. 리스코프 치환 원칙

- 올바른 상속 관계 구축을 위해 따라야 할 지침  
  = 행동 호환성, 대체가능성  
  = 리스코프 치환 원칙

- 서브타입은 기반 타입에 대해 대체 가능해야 한다.
- 클라이언트가 차이점을 인식하지 못한 채 기반 클래스의 인터페이스를 통해 서브클래스를 사용할 수 있어야 한다.
- 행동 호환성을 유지함으로써 부모 클래스를 대체할 수 있도록 구현된 상속 관계만을 서브타이핑 이라 불러야 함

- 대체 가능성을 결정하는 것은 "클라이언트"
  - 중요한 것은 클라이언트 관점에서 행동이 호환되는지 여부
  - 상속관계의 두 클래스를 클라이언트와 떨어트려 놓고 판단하지 말라

- is-a 관계 다시 보기
  - is-a관계는 앞에 "클라이언트 입장에서" 라는 말을 넣어서 생각해야 한다.  
    ex) 클라이언트 입장에서 펭귄은 새인가?
  - is-a관계는 객체지향에서 중요한 것은 객체의 속성이 아니라 객체의 행동이라는 점을 강조한다.
  - 이름이 아니라 행동이 먼저다.
  - 상속이 서브타이핑을 위해 사용될 경우에만 is-a관계다.

- 2장 Movie 설계 다시 보기  
  ![movie다시보기](https://user-images.githubusercontent.com/98109708/153758878-47e545f4-4991-4148-9661-288e23a4450f.jpg)
  - 리스코프 치환 원칙은 클라이언트가 어떤 자식 클래스와도 안정적으로 협력할 수 있는 상속 구조를 구현할 수 있는 가이드라인을 제공
  - 새로운 자식 클래스를 추가해도, 클라이언트가 동일하게 행동하면 클라이언트 수정 없이 상속계층 확장 가능  
    --> 리스코프 치환 원칙을 따르는 설계는 유연하고 확장성 높다.
  - 위의 Movie 예는 2장 OOP에 나온 것으로, 추가로 OverlappedDiscountPolicy를 추가해도 클라이언트 코드 수정 없이 사용 가능하다.
  - 이 설계는 의존성 역전 원칙 / 개방-폐쇄 원칙 / 리스코프 치환 원칙이 어우러져 설계를 확장 가능하게 만든 대표적 예
    - 의존성 역전 원칙 : 구체클래스들이 모두 추상 클래스인 DiscountPolicy에 의존함 (DIP 만족)
    - 리스코프 치환 원칙 : DiscountPolicy와 협력하는 Movie의 관점에서 DiscountPolicy 대신 다른 구현클래스와  
      협력해도 클라이언트에 영향 없이 대체 가능하다. (LSP 만족)
    - 개방-폐쇄 원칙 : 새로운 할인 정책 추가를 위해 DiscountPolicy의 자식 클래스를 추가해도 Movie에 영향을 끼치지 않는다.  
      기능 확장을 하며, 기존 코드를 수정할 필요 없다. (OCP 만족)
  - 리스코프 치환 원칙은 개방-폐쇄 원칙을 만족하는 설계를 위한 전제 조건이다.

- 클래스는 타입계층 구현을 위한 다양한 방법중 하나인 것을 기억하기
  - 단, 클래스를 사용하는 객체지향 언어들이 코드 재사용 목적으로 상속을 많이 사용하므로  
    타입 계층을 위한 예시로 클래스가 많이 언급된다.

- 결론 : 클라이언트 관점에서 슈퍼타입에 대해 기대하는 모든 것이 서브타입에게도 적용돼야 한다는 것


## 05. 계약에 의한 설계와 서브타이핑

- 계약에 의한 설계 (Design By Contract, DBC)  
  클라이언트와 서버 사이의 협력을 의무와 이익으로 구성된 계약 관점에서 표현하는 것
  - 클라이언트가 정상적으로 메소드를 실행하기 위해 만족시켜야 하는 "사전조건"
  - 메소드가 실행된 후 서버가 클라이언트에게 보장해야 하는 "사후조건"
  - 메소드 실행 전, 후에 인스턴스가 만족시켜야 하는 "클래스 불변식"  
    세 가지 요소로 구성된다.

- 서브타입이 리스코프 치환 원칙을 만족시키기 위해서는 클라이언트와 슈퍼타입 간에 체결된 "계약"을  
  준수해야 한다.

- 계약 관점에서 상속이 초래하는 가장 큰 문제는 서브클래스가 슈퍼클래스의 메소드를 오버라이딩 할 수 있다는 것.
- 서브타입과 계약 (Movie 예시)  
  ex. Movie가 알고있는  
  사전조건 : 영화이름은 null이어서는 안된다.  
  사후조건 : 거스름돈은 최솟값이 0이어야 한다.
  - 서브타입에 더 강력한 사전조건을 정의할 수 없다. (영화이름 null아니고, 상영시간은 밤12시 넘어야 함)
  - 서브타입에 슈퍼타입과 같거나 더 약한 사전조건을 정의할 수 있다. (사전조건 주석처리 해도 Movie가 null처리를 해줌)
  - 서브타입에 슈퍼타입과 같거나 더 강한 사후조건을 정의할 수 있다. (거스름톤 최솟값은 1000원 이상으로 함)
  - 서브타입에 더 약한 사후조건을 정의할 수 없다. (거스름돈 - 값 나오도록 함)

- 계약에 의한 설계는 클라이언트 관점에서의 대체 가능성을 계약으로 설명할 수 있다느 사실을 잘 보여준다. (부록 A에 더 자세히)