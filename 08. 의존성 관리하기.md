#의존성 관리하기
- 잘 설계된 객체지향 애플리케이션은 작고 응집도 높은 객체들로 구성
- 작고 응집도 높은 객체? 책임의 초점이 명확하고 한 가지 일만 잘하는 객체
- 작은 객체는 단독 수행이 어려워 다른 객체에게 도움을 요청 = 협력을 낳음
- 협력을 위해 의존성이 필요하지만, 과도한 의존성은 애플리케이션 수정을 어렵게 함
- 객체지향 설계의 핵심을 협력을 위해 필요한 의존성은 유지하며, 변경을 방해하는 의존성을 제거하는 것   
  객체지향 설계 = 의존성 관리

#01. 의존성 이해하기
**변경과 의존성**   
1.의존성의 의미
- 실행 시점 : 의존하는 객체가 정상동작 하려면 실행 시에 의존 대상 객체가 반드시 존재해야 한다.
- 구현 시점 : 의존 대상 객체가 변경되면 의존하는 객체도 함께 변경된다.

2.특징
- 의존성은 방향성을 가지며 항상 단방향이다.

**의존성 전이**
- 의존성이란 의존하고 있는 대상의 변경에 영향을 받을 수 있는 가능성이다.
- 의존성은 전이되며, A가 B에 의존하고 B가 C에 의존한다면 A도 C에 의존하게 될 수도 있다.
- 의존성의 전이는 변경에 의해 영향이 널리 전파될 수 있다는 경고
- 종류
  1. 직접 의존성 : 코드에 명시적으로 드러나는 의존성
  2. 간접 의존성 : 코드에 없지만 의존성 전이에 의해 영향이 전파되는 것
- 클래스뿐만 아니라 변경과 관련된 모든것에 의존성 개념을 적용할 수 있다. (모듈, 시스템도...)

**런타임 의존성과 컴파일타임 의존성**
- 런타임 : 애플리케이션 실행 시점   
  컴파일타입 : 컴파일 시점 or 코드 작성 시점   
  여기서는 코드 작성 시점 자체를 의미한다.
- 런타임의 주인공은 객체. 런타임 의존성이 다루는 주제는 객체 사이의 의존성
- 코드 관점에서의 주인공은 클래스. 컴파일타임 의존성이 다루는 주제는 클래스 사이의 의존성
- 런타임 의존성과 컴파일타임 의존성은 서로 다를 수 있다. ✔
- 컴파일 타임에 추상클래스A에 의존하는 클래스B는, 실행 시 인스턴스(추상클래스A의 구현클래스C)에   
  대한 런타임 의존성으로 대체한다.
- 유연하고 확장 가능한 설계를 위해서는 컴파일타임 의존성과 런타임 의존성이 달라야 한다.
- 클래스는 자신과 협력할 객체의 구체적인 클래스에 대해 알아서는 안된다.

**컨텍스트 독립성**
- 시스템을 구성하는 객체가 컨텍스트 독립적이면 해당 시스템은 변경이 쉽다.
- 컨텍스트 독립적이라는 말은, 각 객체가 해당 객체를 실행하는 시스템에 관해 알지 못한다는 의미다.

**의존성 해결하기**
- 컴파일타임 의존성은 구체적인 런타임 의존성으로 대체돼야 한다.
- 컴파일타임 의존성을 실행 컨텍스트에 맞는 적절한 런타임 의존성으로 교체하는 것을 의존성 해결이라 한다.
- 의존성해결은 생성자/setter/메소드인자를 이용해 가능하다.

##02. 유연한 설계
**의존성과 결합도**
- 객체들이 협력하기 위해서는 서로의 존재와 수행가능한 책임을 알아야 한다.
- 이는 객체사이의 의존성을 낳는다.
- 의존성은 객체들의 협력을 가능하게 만드는 매개체라는 관점에서 바람직하다.
- 바람직한 의존성이란? 재사용성과 관련이 있다.
- 어떤 의존성이 다양한 환경에서 클래스를 재사용할 수 없도록 제한한다면, 바람직하지 못한 의존성이다.
- 컨텍스트에 독립적인 의존성은 바람직하며, 특정 컨텍스트에 강하게 결합된 의존성은 바람직하지 않은 의존성이다.
- 다른 환경에서 재사용하기 위해 내부 구현을 변경하게 만드는 모든 의존성은 바람직하지 않은 의존성
- 결합도   
  1) 어떤 두 요소 사이에 존재하는 의존성이 바람직 할 때 : 느슨한 결합도 / 약한 결합도
  2) 두 요소 사이의 의존성이 바람직하지 못할 때 : 단단한 결합도 / 강한 결합도

**자식이 결합을 낳는다**
- 결합도의 정도는 한 요소가 자신이 의존하는 다른 요소에 대해 알고 있는 정보의 양으로 결정된다.
- 추상화를 통해 결합도를 느슨하게 할 수 있다.

**추상화에 의존하라**
- 추상화랑 세부사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로   
  생략하거나 감춤으로써 복잡도를 극복하는 방법
- 추상화를 사용하면 다루고 있는 문제를 해결하는 데 불필요한 정보를 감출 수 있다.
- 대상에 대해 알아야 하는 정보(지식의 양)을 줄이면 결합도를 느슨하게 유지할 수 있다.
- 의존하는 대상이 추상적일수록 결합도는 더 낮아진다.
  1) 구체 클래스 의존성
  2) 추상 클래스 의존성
  3) 인터페이스 의존성 (가장 결합도 낮음)

**명시적인 의존성**
- 의존성 대상을 생성자의 인자로 전달받아야 한다.   
  이 경우 의존성은 명시적으로 퍼블링 인터페이스에 노출되는데, 이를 "명시적인 의존성"이라 한다.
- 반면에 내부에서 NEW를 통해 인스턴스를 직접 생성하면,   
  의존성이 퍼블릭 인터페이스에 표현되지 않는데, 이를 "숨겨진 의존성"이라 한다.
- 의존성은 명시적으로 표현돼야 한다.
- 의존성을 구현 내부에 숨기면 다른 컨텍스트에서 재 사용시 내부 구현을 변경해야 한다.
- 유연하고 재사용 가능한 설계란 퍼블릭 인터페이스를 통해 의존성이 명시적으로 드러나는 설계다.

**new는 해롭다**
- new를 잘못 하면하면 클래스 사이의 결합도가 극단적으로 높아진다.
  1) new를 사용하면 구체클래스의 이름을 직접 기입해야 한다 -> 결합도 높힘
  2) 구체 클래스뿐만 아니라 어떤 인자를 이용해 생성자를 호출해야 하는지 알아야 하므로   
     클라이언트가 알아야 하는 지식의 양이 늘어난다 -> 결합도 높힘
- 사용과 생성의 책임을 분리하고, 의존성을 생성자에 명시적으로 드러내고,   
  구체 클래스가 아닌 추상클래스에 의존하게 함으로써 설계를 유연하게 할 수 있다.

**가끔은 생성해도 무방하다**
- 협력하는 기본객체를 설정하고 싶은 경우, 직접 생성하는 방식이 사용될 수 있다.   
  ex) 생성자 여러개 선언하고, 인자가 안 넘어온 경우 디폴트 구체클래스를 new 하는 방식
- 메소드 오버라이딩시 인자값에 따라서도 사용할 수 있다.

**표준 클래스에 대한 의존은 해롭지 않다**
- 의존성은 변경에 대한 영향을 암시하므로 불편하다.
- 따라서 변경될 확률이 거의 없는 클래스라면 의존성이 문제되지 않는다.   
  ex) jdk표준 클래스 ArrayList는 new로 직접 생성한다.
- 하지만 확장성을 위해 List로 선언하고 구체클래스로 생성하는게 더 좋다.

**컨텍스트 확장하기**
- 결합도를 낮춤으로써 얻게 되는 컨텍스트의 확장이라는 개념이 유연하고 재사용 가능한 설계를 만드는 핵심이다.

**조합 가능한 행동**
- 유연하고 재사용 가능한 설계는 작은 객체들의 행동을 조합하여 새로운 행동을 이끌어내는 설계다.
- 훌륭한 객체지향 설계란 객체가 어떻게 하는지를 표현하는 것이 아니라,   
  객체들의 조합으로 객체들이 무엇을 하는지 표현하는 설계다.
- 이런 설계를 창조하는 데 있어서의 핵심은 의존성을 관리하는 것이다.
