# 상속과 코드 재사용
- 객체지향 장점 : 코드 재사용
  - 코드 재사용 방법 ? '새로운' 코드 추가
  - 대표 기법 : 상속, 합성

## 01. 상속과 중복 코드
**DRY 원칙**
- 중복 코드는 변경을 방해하므로, 이것이 중복 코드를 제거해야 하는 가장 큰 이유
- Don't Repeat Yourself (반복하지 마라!)  
  모든 지식은 시스템 내에서 단일하고, 애매하지 않고, 정말로 믿을 만한 표현 양식을 가져야 한다.

**상속을 이용해서 중복 코드 제거하기**
- A클래스와 유사한 클래스가 필요할 경우, A를 상속받는 B클래스를 만든다.
  - A클래스 재사용
  - 중복코드 없음
- 단, 상속은 결합도를 높이기도 한다.
  - 상속이 초래하는 부모 클래스와 자식 클래스의 강한 결합이 코드 수정을 어렵게 만든다.

> 상속을 위한 경고1
> 자식 클래스의 메소드 안에서 SUPER 참조를 이용해 부모 클래스의 메소드를  
> 직접 호출할 경우, 두 클래스는 강하게 결합된다.  
> SUPER 호출을 제거할 수 있는 방법을 찾아 결합도를 재거하라.

- 상속 관계로 연결된 자식 클래스가 부모 클래스의 변경에 취약해 지는 현상을  
  취약한 기반 클래스 문제라고 한다.
- 취약한 기반 클래스 문제는 코드 재사용을 목적으로 상속을 사용할 때 방생하는 가장 대표적인 문제

## 02. 취약한 기반 클래스 문제
- 부모 클래스의 변경에 자식 클래스가 영향을 받는 현상
- 취약한 기반 클래스 문제는 상속이라는 문맥 안에서 결합도가 초래하는 문제점을 가리키는 용어다.
  - 구현을 상속한 경우(extends) 파생 클래스는 기반 클래스에 강하게 결합된다.
  - 기반 클래스를 변경할 경우 모든 파생 클래스를 살펴야 한다.
  - 상속관계를 추가할 수록 시스템 결합도는 높아지고, 부모 클래스 개선은 어려워 진다.
  - 그리고 자식 클래스가 부모 클래스의 구현에 의존하므로 캡슐화를 약화시킨다.
- 이는 상속이 위험한 이유이며, 우리가 상속을 피해야 하는 첫 번째 이유다.

**상속의 문제점**
- 문제1 ) 불필요한 인터페이스 상속 문제
  - 상속받은 부모 클래스의 메소드가 자식 클래스의 내부 구조에 대한 규칙을 깨트릴 수 있다.
- 문제2 ) 메소드 오버라이딩의 오작용 문제
  - 자식 클래스가 부모 클래스의 메소드를 오버라이딩 할 경우, 부모 클래스가 자신의 메소드를  
   사용하는 방법에 자식 클래스가 결합될 수 있다.

- 클래스에서는 메소드 오버라이딩으로 인한 파급 효과를 문서화 해야 한다. (내부 구현을 문서화)
  - 설계는 트레이드 오프의 산물!
  - 상속은 코드 재사용을 위해 캡슐화를 희생한다.
  - 서브클래스가 안전할 수 있게 클래스를 문서화 하려면 상세 구현 내역을 기술 해야 한다.

- 문제3 ) 부모 클래스와 자식 클래스의 동시 수정 문제
  - 클래스를 상속하면 결합도로 인해 자식 클래스와 부모 클래스의 구현을 영원히 변경하지 않거나,  
    자식 클래스와 부모 클래스를 동시에 변경하거나 둘 중 하나를 선택할 수 밖에 없다.

- 결합도 : 다른 대상에 대해 알고 있는 지식의 양
  - 상속은 부모 클래스의 구현을 재사용한다는 전제를 따르므로, 자식 클래스가 부모 클래스의  
    내부에 대해 알도록 강요한다.
  - 코드 재사용을 위한 상속은 부모 클래스와 자식 클래스를 강하게 결합시킨다.  
    (부모 수정시 자식 수정 빈번히 발생)

## 03. 상속으로 인한 피해 최소화 해보기
- 취약한 기반 클래스 문제를 완전히 없앨 수 없지만, 위험을 완화시키는 것은 가능

1.추상화에 의존하자
- 자식 클래스가 부모 클래스의 구현이 아닌 추상화에 의존하도록 하자

2.차이를 메소드로 추출하라
- 중복 코드안에서 차이점을 별도 메소드로 추출한다.

3.중복 코드를 부모 클래스로 올려라
- 차이점이 메소드로 분리하면 중복 코드만 남는데, 이를 추상 클래스로 올린다.

**추상화가 핵심이다**
- 공통 코드를 이동시키면 각 클래스는 서로 다른 변경의 이유를 갖게 된다.
  - AbstractPhone : 전체 통화 목록 계산 방법이 바뀔 때 변경
  - Phone : 일반 요금제의 통화 한 건을 계산하는 방식이 바뀔 때 변경
  - NightlyDiscountPhone : 심야 할인 요금제의 통화 한 건을 계산하는 방식이 바뀔 때 병경
- 각각 하나의 변경 이유만을 가지는 클래스들은 단일 책임 원칙을 준수하므로 응집도가 높다.
- 추상화가 적용되면, 확장에는 열려 있고 수정에는 닫힌 개발-폐쇄 원칙을 준수한다.
  --> 클래스들이 추상화에 의존할 경우 얻어지는 장점들

**의도를 드러내는 이름 선택하기**
![KakaoTalk_20211006_002434753](https://user-images.githubusercontent.com/67268117/136053819-95ff3002-5a2b-45a6-8e95-7abec95877e2.jpg)
- 추상화에 의존하면 새로운 클래스 추가도 쉬워진다.
  - Phone을 상속받고, calculateCallFee() 메소드만 오버라이딩 하면 됨!

> 하지만 새로운 인스턴스 변수(TaxRate)를 Phone에 추가 하게 되면..  
> 자식 클래스의 생성자도 모두 바뀌어야 한다.  
> 하지만 인스턴스 초기화 로직을 변경하는 것이 두 클래스에 동일한 세금 계산 코드를  
> 중복 시키는 것보다 현명한 선택!

- 상속으로 인한 클래스 사이의 결합은 피할 수 없다.  
  메소드 구현에 대한 결합은 추상 메소드를 추가해 완화할 수 있지만   
  인스턴스 변수에 대한 잠재적인 결합을 제거할 수 있는 방법은 없다.
- 해야할 일? 행동을 변경하기 위해 인스턴스 변수를 추가하더라도 상속 계층 전체에 걸쳐 부작용이 퍼지지 않게 막는 것!

## 04. 차이에 의한 프로그래밍
- 상속이 강력한 이유 : 익숙한 개념을 이용해서 새로운 개념을 쉽고 빠르게 추가할 수 있다.
- 기존 코드와 다른 부분만 추가하여 애플리케이션의 기능을 확장하는 방법 -> 차이에 의한 프로그래밍
- 파이에 의한 프로그래밍의 목표
  - 중복 코드를 제거하고 코드를 재사용 하는 것
- 상속은 강력하지만, 맹목적인 상속남용은 위험하다.
  - 상속의 단점을 피하며, 코드를 재사용할 수 있는 더 좋은 방법 ? "합성"
 