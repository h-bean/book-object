# 책임 할당하기

##책임주도 설계를 향해
1.데이터보다 행동을 먼저 결정하라
 - 데이터는 객체가 책임을 수행하는 데 필요한 재료를 제공할 뿐
 - "이 객체가 수행해야 하는 책임은 무엇인가"   
   다음이, "이 책임을 수행하는데 필요한 데이터는 무엇인가"

2.협력이라는 문맥 안에서 책임을 결정하라
 - 책임은 객체의 입장이 아닌, 객체가 참여하는 협력에 적합해야 한다.
 - 메시지가 존재하기 때문에 그 메시지를 처리할 객체가 필요한 것
 - "이 클래스로 무엇을 해야하지?" --> "메시지를 전송해야 하는데, 누구에게 전송하지?"
 - 협력이라는 문맥에서 적절한 책임은 클라이언트 관점에서 적절한 책임   
   객체를 결정하기 전에, 객체가 수신할 메시지가 먼저 결정된다.

3.책임 주도 설계
 - 협력이라는 문맥 안에서 객체가 수행할 책임에 초점을 맞춘다.
 - 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 한다.

##책임 할당을 위한 GRASP 패턴
GRASP패턴 : 객체에게 책임을 할당할 때 지침으로 삼는 원칙들 (크레이그 라만)

**도메인 개념에서 출발하기**
![KakaoTalk_20210809_230641835](https://user-images.githubusercontent.com/67268117/128719778-d872d3fb-9e5a-4af2-aa61-5815022e7341.jpg)
 - 어떤 책임을 할당해야 할 때, 가장 먼저 고민해야 하는 유력한 후보는   
   도메인 이다.
 - 올바른 도메인 모델이란 존재하지 않는다.

**정보 전문가에게 책임을 할당하라**
> 책임 주도 설계 방식의 첫 단계는, 애플리케이션이 제공해야 하는 기능을   
> 애플리케이션의 책임으로 생각하는 것이다.   
> 이 책임을 애플리케이션에 대해 전송된 메시지로 간주하고,   
> 이 메시지를 책임 질 첫 번째 객체를 선택하는 것으로 설계를 시작한다.

1.영화예메 시스템 : 메시지를 전송할 객체가 원하는 것? "예매하라"   
2.메시지를 수신할 적합한 객체는?
 - 객체에게 책임을 할당하는 첫 번째 원칙은 책임을 수행할 정보를 알고 있는   
   객체에게 책임을 할당하는 것
> Information expert (정보 전문가) 패턴   
> 정보를 알고 있는 객체만이 책임을 어떻게 수행할지 스스로 결정할 수 있다. (자율적인 객체)   
> 여기서 정보란 데이터가 아니다.   
> 책임을 수행할 객체가 정보를 '알고' 있다고 해서 그 정보를 '저장'하고 있을 필요는 없다.

 - 예매하는 데 필요한 정보를 가장 많이 알고있는 객체? "상영"   
   상영에게 예매를 위한 책임을 할당
   
3.Screening의 내부로 들어가 메시지 처리를 위한 절차와 구현을 고민하자
 - 책임을 수행하는 데 필요한 작업을 구상해보고 스스로 처리할 수 없는   
   작업이 무엇인지 가릴 정도로만...
 - 스스로 처리할 수 없는 작업이 새로운 메시지가 되고, 다른 객체에게 책임을 할당
 - 예매를 하기 위해 예매 가격 계산 작업이 필요 --> "계산하라"

4.영화 가격 계산에 필요한 정보를 알고 있는 전문가? "영화"

5.Movie가 계산을 위해 해야하는 작업
 - "할인여부를 판단"해서 할인 정책에 따라 할인 요금을 제외한 금액을 계산한다.

6."할인여부를 판단하라" --> "할인조건" 도메인
 - DiscountCondition에게 메시지를 전송한다.

**높은 응집도와 낮은 결합도**   
1. 설계란 트레이드오프의 활동이므로 동일한 기능을 구현할 수 있는 수많은 설계가 존재한다.
2. 단, 높은 응집도와 낮은 결합도는 객체에 책임을 할당할 때 항상 고려해야 하는 기본 원리다.
3. 여러가지 협력 패턴 중, 높은 응집도와 낮은 결합도를 얻을 수 있는 설계를 선택한다.

> LOW COUPBLING(낮은 결합도) 패턴 & HIGH COHESION(높은 응집도) 패턴   
> 어떻게 하면 의존성을 낮추고 변화의 영향을 줄이며 재사용성을 증가시킬 수 있을까?   
> 어떻게 복잡성을 관리할 수 있는 수준으로 유지할 것인가?   
> 이 둘은 모든 설계 결정을 평가할 때 적용할 수 있는 평가원리다.

**창조자에게 객체 생성 책임을 할당하라**
- "Reservation" 인스턴스의 생성

> CREATOR 패턴   
> 객체를 생성할 책임을 어떤 객체에게 할당할지에 대한 지침 제공   
> 생성할 객체를 잘 알고있는 객체에게 객체 생성 책임을 할당한다.   
> CREATOR 패턴은 이미 존재하는 객체 사이의 관계를 이용하여 설계가 낮은 결합도를 유지할 수 있게 한다.

##구현을 통한 검증
✔ 설계 개선 작업은, 변경의 이유가 하나 이상인 클래스를 찾는 것으로부터 시작하자
 - 인스턴스 변수가 초기화 되는 시점   
  : 클래스의 속성이 서로 다른 시점에 초기화되거나 일부만 초기화된다는 것은    
    응집도가 낮다는 증거   
  : 함께 초기화되는 속성을 기준으로 코드를 분리해야 한다.    
 - 메소드들이 인스턴스 변수를 사용하는 방식   
  : 모든 메소드가 객체의 모든 속성을 사용한다면 클래스의 응집도는 높다.   
    반대로 메소드들이 사용하는 속성에 따라 그룹이 나뉜다면 클래스의 응집도는 낮다.   
  : 속성 그룹과 해당 그룹에 접근하는 메소드 그룹을 기준으로 코드를 분리해야 한다.

✔ 방법   
1.타입 분리하기
 - DiscountCondition을 PeriodCondition과 SequenceCondition으로 나누기   
   : 각 클래스의 응집도 높아짐
 - Movie가 두 클래스에 결합되어 전체적인 결합도는 증가됨
   
2.다향성을 통해 분리하기
 - Movie입장에서 PeriodCondition과 SequenceCondition은 차이가 없다!   
   둘 모두 할인 여부를 판단하는 동일한 책임을 수행할 뿐
 - "역할" 개념의 등장   
   역할은 협력 안에서 대체 가능성을 의미하기 때문에 두 클래스에 역할의 개념을 적용하면 Movie는
   구체적인 클래스는 알지 못한 채 오직 역할에 대해서만 결합되도록 의존성을 제한할 수 있다.   
 - 객체의 구체적 타입을 추상화 하자 (추상클래스 or 인터페이스)
 - 구현을 공유할 필요가 없는 PeriodCondition과 SequenceCondition는   
   DiscountCondition 인터페이스로 역할을 구현 할 수 있다.

> POLYMORPHISM 패턴   
> 객체의 타입에 따라 변하는 로직이 있을 때 변하는 로직을 담당할 책임을 어떻게 할당해야 하는가?   
> 타입을 명시적으로 정의하고 각 타입에 다형적으로 행동하는 책임을 할당하라   
> POLYMORPHISM 패턴은 객체의 타입 검사를 통해, 타입에 따라 여러 대안을   
> 수행하는 조건적 논리를 사용하지 말라고 경고한다. (if ~ else 사용하지 말라!)   
> 대신 다형성을 이용해 새로운 변화를 다루기 쉽게 확장하라고 권고한다.

3.변경으로부터 보호하기
 - 새로운 할인조건이 추가되는 경우, Movie에 영향 없이    
   DiscountCondition 인터페이스를 실체화 하는 클래스를 추가하면 된다.
 - 이처럼 변경을 캡슐화하도록 책임을 할당하는 것을   
   PROTECTED VARIATION(변경보호) 패턴이라 한다.

> PROTECTED VARIATION 패턴   
> 이 패턴은 책임 할당의 관점에서 캡슐화를 설명한 것   
> 우리가 캡슐화 해야 하는 것은 변경이다. 변경될 가능 성이 높다면 캡슐화 하라

★ 클래스를 변경에 따라 분리하고 인터페이스를 이용해 변경을 캡슐화하는 것은 설계의 결합도와
  응집도를 향상시키는 매우 강력한 방법이다.   
 - 하나의 클래스가 여러 타입의 행동을 구현하고 있다면 클래스를 분해하고   
    POLYMORPHISM 패턴에 따라 책임을 분산시켜라
 - 예측 가능한 변경으로 인해 클래스들이 불안정해 진다면   
    PROTECTED VARIATIONS 패턴에 따라 안정적인 인터페이스 뒤로    
    변경을 캡슐화 하라.

![KakaoTalk_20210810_235026349](https://user-images.githubusercontent.com/67268117/128889087-248a1871-93a1-4c1d-af73-a0e3dbcb80e9.jpg)
 - 위 설계는 도메일 모델의 구조와 유사하다.
 - 도메인 모델은 단순히 설계에 필요한 용어를 제공하는 것을 넘어   
   코드의 구조에도 영향을 준다.
 - 구현을 가이드 할 수 있는 도메인 모델을 선택하라.

4.변경과 유연성
 - 변경에 대비하는 방법   
   1) 코드를 이해하고 수정하기 쉽도록 최대한 단순하게 설계 (선호함)
   2) 코드를 수정하지 않고 변경을 수용할 수 있도록 코드를 유연하게 만듦
 - 변경이 반복적으로 발생한다면 복잡성이 상승해도 유연성을 추가하는 방법 채택
 
![KakaoTalk_20210810_235514295](https://user-images.githubusercontent.com/67268117/128889879-46bcd42c-3d44-42dc-88c4-3c4065e7350b.jpg)
 - 영화에 설정된 할인 정책을 변경해야 한다면?
 - 상속을 이용하고 있기 때문에, 새로운 인스턴스를 생성한 후   
   필요한 정보를 복사해야 하고 식별자 관리 코드를 추가해야 한다.
 - 해결방법 : 합성을 사용하는 것
 - Movie의 상속 계층 안에 구현된 할인정책을 독립적인 DiscountPolicy로 분리한 후 Movie에 합성시킨다.
 - 요소들 사이의 의존성의 정도가 유연성의 정도를 결정한다.

![KakaoTalk_20210811_000041409](https://user-images.githubusercontent.com/67268117/128890837-571777d9-89f7-4914-a966-a8e57264006e.jpg)
 - 도메인 모델은 구현과 밀접한 관계를 맺는다.
 - 따라서 도메인 모델도 코드의 관점에 따라 바뀌어야 한다.

##책임주도 설계의 대안
 - 리팩토링 : 소프트웨어 개선을 위해 겉으로 보이는 동작은 바꾸지 않은 채,   
  내부 구조를 변경하는 것