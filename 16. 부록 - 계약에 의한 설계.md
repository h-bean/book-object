# 계약에 의한 설계

- 계약에 의한 설계 (Design By Contract, DBC)를 사용하면 협력에 필요한 다양한 제약과 부수효과를 명시적으로  
  정의하고 문서화 할 수 있다.
  - 명령의 부수효과를 쉽고 명확하게 표현할 수 있는 커뮤니케이션 수단

- 계약에 의한 설계를 사용하는 이유와 장점을 이해하는 것이 목표.

## 01. 협력과 계약

- 객체지향의 핵심은 협력 안에서 객체들이 수행하는 행동
- 메시지 이름과 파라미터는 시그니처를 통해 전달할 수 있지만, 협력을 위해 필요한 약속과 제약은 인터페이스를  
  통해 전달할 수 없다.
  - 계약에 의한 설계를 하면 가능!
- 계약에 의한 설계를 사용하면 "제약 조건을 명시적"으로 표현하고 자동으로 "문서화"할 수 있을뿐만 아니라 "실행을 통해 검증" 할 수 있다.
- 계약은 협력을 명확하게 정의하고 커뮤니케이션할 수 있는 범용적인 아이디어  
  --> 계약을 객체들의 협력 방식에 적용하자! (버트란드 마이어)

## 02. 계약에 의한 설계
- 버트란드 마이어의 계약의 개념은, 협력에 참여하는 두 객체 사이의 의무와 이익을 문서화 한 것.
  - 협력에 참여하는 각 객체는 계약으로부터 "이익"을 기대하고 이익을 얻기 위해 "의무"를 이행한다.
  - 협력에 참여하는 각 객체의 이익과 의무는 객체의 인터페이스 상에 "문서화"된다.

- 자바의 경우 언어 차원에서 계약에 의한 설계 개념을 지원하지 않음
  - 언어 차원에서 지원하지 않아도 계약에 의한 설계를 적용하는 것은 가능하다.

- 사전 조건
  - 메소드가 호출되기 위해 만족돼야 하는 조건.  
    사전조건을 만족시키는 것을 메소드를 실행하는 클라이언트의 의무다.

- 사후 조건
  - 메소드가 실행됭 후 클라이언트에게 보장해야 하는 조건.  
    사후조건을 만족시키는 것은 서버의 의무다.

- 불변식
  - 항상 참이라고 보장되는 서버의 조건
  - 인스턴스 생명주기 전반에 걸쳐 지켜져야 하는 규칙을 명세
  - 사전조건, 사후조건에 추가되는 공통의 조건

## 03. 계약에 의한 설계와 서프타이핑

- 계약에 의한 설계와 리스코프 치환 원칙이 만나는 지점  
  : 서브타입이 리스코프 치환 원칙을 만족시키기 위해서는 클라이언트와 슈퍼타입 간에 체결된 "계약"을 준수해야 한다.

- 리스코프 치환 원칙 ?  
  슈퍼타입의 인스턴스와 협력하는 클라이언트 관점에서 서브타입의 인스턴스가 슈퍼타입을 대체해도 협력에  
  지장이 없어야 한다는 것을 의미
  - 종류
    - 계약규칙 : 협력에 참여하는 객체에 대한 기대 표현
    - 가변성 규칙 : 교체 가능한 타입과 관련

- 계약 규칙
  - 서브타입이 슈퍼타입에 정의된 사전조건을 강화하면 기존에 체결된 계약을 위반하게 됨  
    --> 사전조건 강화는 리스코프 치환 원칙 위반
  - 사전 조건 완화는 리스코프 치환 원칙을 위반하지 않음
  - 계약의 관점에서 사후조건은 완화할 수 없다.  
    --> 사후조건을 완화시키는 서버는 클라이언트 관점에서 수용할 수 없기 때문에 슈퍼타입 대체 불가
  - 사후조건 강화는 계약에 영향을 미치지 않음
  - 슈퍼타입의 불변식은 서브타입에서도 반드시 유지돼야 한다.

- 가변성 규칙
  - 서브타입은 슈퍼타입이 발생시키는 예외와 다른 타입의 예외를 발생시켜서는 안된다.
    - 슈퍼타입이 던지는 예외가 속한 상속 계층이 아닌 다른 상속 계층에 속하는 예외를 던질 경우  
      자식 클래스는 부모 클래스를 대체할 수 없다.
    - 클라이언트 관점에서 부모 클래스보다 더 적은 일을 수행하는 자식 클래스는 부모 클래스를 대체  
      할 수 없다.  
      --> 따라서 서브타입이 아니다.
  - 서브타입의 리턴 타입은 공변성을 가져야 한다. (제네릭 관련)
    - 공변성 : 서브타입관계 유지. 서브타입이 슈퍼타입 대체 가능. 리스코프 치환원칙은 공변성 관련 원칙
    - 반공변성 : 서브타입관계 역전. 슈퍼타입이 서브타입 대신 사용될 수 있음
    - 무공변성 : 아무런 관계 없음. 서로 대신 사용할 수 없음
  - 공변성과 반공변성은 타입의 관계(서브타입이 슈퍼타입 대체가능)이 아니라, 메소드의 리턴타입과  
    파라미터 타입에 초점을 맞추어야 한다.
    - 리턴타입 공변성 : 부모 클래스에서 구현된 메소드를 자식 클래스에서 오버라이딩할 때 부모  
      클래스에서 선언한 반환타입의 서브타입으로 지정할 수 있는 특성
      - 메소드를 구현한 클래스의 타입 계층 방향과 리턴 타입의 타입 계층 방향이 동일한 경우
    - 자바는 리턴타입 공변성을 지원. C#은 지원하지 않음(컴파일 에러)
  - 서브타입의 메소드 파라미터는 반공변성을 가져야 한다.
    - 파라미터 타입 반공변성 : 부모 클래스에서 구현된 메소드를 자식 클래스에서 오버라이딩 할 때  
      파라미터 타입을 부모 클래스에서 사용한 파라미터의 슈퍼타입으로 지정할 수 있는 특성
      - 메소드를 정의한 클래스의 타입 계층과 파라미터 타입 계층의 방향이 반대인 경우 서브타입 관계를 만족
    - 자바는 파라미터 반공변성을 지원X(오버로딩으로 판단)
  
> 서브타입이 슈퍼타입을 치환할 수 있다는 것은 계약에 의한 설계에서 정의한 계약 규칙과  
> 가변성 규칙을 준수한다는 것을 의미한다.