# 다형성
- 상속의 본래 목적 은?
  - 코드 재사용이 아님 !!!!!
  - 타입 계층을 구조화 하기 위해 사용해야 함
- 객체지향 패러다임 초기, 상속은 타입 계층과 다형성을 구현할 수 있는 거의 유일한 방법

😊 목표  
 1. 상속의 진정한 목적은 코드 재사용이 아님을 이해하는 것  
 2. 포함 다형성 관점에서 런타임에 상속 계층 안에서 적절한 메소드를 선택하는 방법을 이해하는 것

## 01. 다형성
- 다형성 : 여러 타입을 대상으로 동작할 수 있는 코드를 작성할 수 있는 방법
- 다형성의 분류
  1) 오버로딩 다형성  
     하나의 클래스 안에 동일한 이름의 메소드가 존재하는 경우
  2) 강제 다형성  
     언어가 지원하는 or 사용자가 구현한 타입 변환을 이용해 동일한 연산자를  
     다양한 타입에서 사용할 수 있는 방식 (ex. +연산자는 숫자끼리의 덧셈 / 문자열에 사용되면 연결) 
  3) 매개변수 다형성  
     클래스의 인스턴스 변수나, 메소드의 매개변수 타입을 임의의 타입으로 선언한  
     후, 사용하는 시점에 구체적인 타입으로 지정하는 방식 (ex. 제네릭 프로그래밍 List<T>)
  4) 포함 다형성  
     일반적으로 말하는 다형성. 메시지가 동일해도 수신한 객체의 타입에 따라 실제로 수행되는 행동이  
     달라지는 능력

- 포함 다형성을 구현하는 가장 일반적인 방법 = 상속
- 상속의 진정한 목적은 코드 재사용이 아닌, 다형성을 위한 서브타입 계층을 구축하는 것 ✔ 

## 02. 상속의 양면성
- 상속의 목적은 코드 재사용이 아니다.  
  상속은 프로그램을 구성하는 개념들을 기반으로 다형성을 가능하게 하는 타입 계층을 구축하기 위한 것.
- 상속의 내부 메커니즘, 다형성의 동작 방식을 이해 하자

- 데이터 관점의 상속  
  자식 클래스의 인스턴스 안에 부모 클래스의 인스턴스를 포함하는 것.  
  자식 클래스의 인스턴스는 자동으로 부모 클래스에서 정의한 모든 인스턴스 변수를 내부에 포함

- 행동 관점의 상속  
  부모 클래스가 정의한 일부 메소드를 자식 클래스의 메소드로 포함시키는 것
  - How? 런타임에 시스템이 자식 클래스에 정의되지 않은 메소드가 있을 경우, 이 메소드를 부모 클래스  
    안에서 탐색 한다.
  - 객체가 실행 시점에 메소드를 탐색하는 과정 (중요)

## 03. 업캐스팅과 동적 바인딩
- 코드 안에서 선언된 참조 타입과 무관하게, 실제로 메시지를 수신하는 객체의 타입에 따라 실행되는  
  메소드가 달라질 수 있는 것은 업캐스팅과 동적 바인딩 메커니즘이 자굥앟기 때문
  - 업캐스팅 : 부모 클래스 타입으로 선언된 변수에 자식 클래스의 인스턴스 할당 가능
  - 동적 바인딩 : 선언된 변수 타입이 아닌 메시지를 수신하는 객체의 타입에 따라 실행되는 메소드가 결정됨  
    객체지향 시스템이 메시지를 처리할 적절한 메소드를 컴파일 시점이 아닌 실행 시점에 결정하기 때문

- 개방 - 폐쇄 원칙 : 유연하고 확장 가능한 코드를 위한 의존관계 구조화 방법 설명 (목적)
  - 업캐스팅 & 동적 바인딩 (목적에 이르는 방법)  
  - 소스코드 변경 없이 유연하게 자식 or 부모 메소드 호출이 가능하다.

- 대표적 업캐스팅 예
  - 대입문 (부모타입 선언, 자식타입 new 가능)
  - 파라미터 타입 (부모타입 선언, 자식타입 인스턴스 전달 가능)

- 클래스 A는 부모클래스 B를 이용한다.  
  그렇다면 A는 B를 상속받는 어떤 자식 클래스와도 소스코드 변경 없이 협력할 수 있는  
  무한한 확장 가능설을 가진다.  
  --> 유연하며 확장이 용이한 설계

- 바인딩 차이
  - 정적 바인딩 : 함수 호출 (호출될 함수를 컴파일 타임에 결정 / 소스 작성 시 결정되는것!)
  - 정적 바인딩(지연 바인딩)  
    : 실행 시점에 어떤 클래스의 인스턴스를 생성해서 전달하는지를 알아야만 실제로 실행되는 메소드를  
    알 수 있다.

- 객체지향은, 어떤 규칙에 따라 메소드 전송과 메소드 호출을 바인딩 하는 것인지?

##04. 동적 메소드 탐색과 다형성
- self(this) 참조
  - 메시지 탐색은 this참조가 가리키는 메시지 최초 수신 객체(가장 하위 자식)로 부터  
    부모 클래스로 거슬러 올라가며 (class 포인터, parent 포인터 이용) 진행된다.  
    메소드를 찾으면 실행 후 탐색을 종료하고, Object까지 갔는데 찾지 못하면 에러를 발생시키고  
    메서드 탐색을 종료 한다.
  - 동적 메소드 탐색은  
    자동적인 메시지 위임 : 자식이 처리할 수 없는 메시지를 부모에게 위임 (상속 계층을 따라 자동으로 발생)  
    동적인 문맥 : 실제 어떤 메소드가 실행될지 실행시점에 결정

- 자동적인 메시지 위임
  - 상속을 이용하면 개발자가 메시지 위임과 관련된 코드를 명시적으로 작성X
  - 메시지는 상속 계층을 따라 부모 클래스에게 자동 위임
  - 상속 계층을 정의하는 것? 메소드 탐색 경로를 정의하는 것!

- 메소드 오버라이딩은 부모 클래스의 메소드를 가리는 것 처럼 보인다.  
  오버로딩은 부모 클래스 메소드와 공존한다.
  - 상속 계층에서도 오버로딩이 있을 수 있다!! (지원 안하는 언어도 있음 EX. C++)  
  --> 동적 메소드 탐색과 관련된 규칙은 언어마다 다를 수 있다.

- 동적인 문맥
  - 메시지를 수신할 객체가 무어냐에 따라 메소드 탐색을 위한 문맥이 동적으로 바뀐다.  
    동적인 문잭을 결정하는 것은 메시지를 수신한 객체를 가리키는 self 참조.
  - self 전송?
    - 메시지는 현재 클래스가 아닌 현재 객체에게 전송된다. ✔  
      ```java
      public class Lecture {
          public String stats() {
              return String.format("Title : %s, Mehotd : %s". title, getEvaluationMethod());
          }
      
          public String getEvaluationMethod() {
              return "Pass or Fail";
          }
      }
      
      public class GradeLecture extends Lecture {
          @Override
          public String getEvaluationMethod() {
              return "Grade";
          }
      }
      ```
      - 이 예제에서, 아래 메소드 호출은 문제 되지 않음.  
        Lecture lecture = new Lecture();  
        lecture.stats();   
        ![KakaoTalk_20220210_220530648](https://user-images.githubusercontent.com/98109708/153414253-df99bea0-92f2-45b9-9281-3d7105e1dd53.jpg)
      - 상속(+ 오버라이딩)이 끼어들면 문제가 달라짐!  
        Lecture gLecture = new GradeLecture();  
        gLecture.stats();  
        self 참조로, stats() 내부에서 Lecture가 아닌 this의 GradeLecture.getEvaluationMethod()가 호출됨!  
        즉, 부모 메소드가 호출되어도, 자식으로 생성되면 메소드 호출이 일어날 시 무조건  
        this부터 탐색한다 ✔✔  
        ![KakaoTalk_20220210_220530648_01](https://user-images.githubusercontent.com/98109708/153414264-cd2b1938-5d6a-4296-a142-fbaea3a5c905.jpg)
  - self 전송이 이루어지면, 정말 복잡한 메소드 탐색이 발생할 수 있음을 주의
  
- 이해할 수 없는 메시지 처리  
  : 메소드를 못 찾는 경우
  - 정적 타입 언어 : 컴파일 단계에서 에러 발생
  - 동적 타입 언어
    - 순수한 관점의 객체지향 패러다임을 구현
    - 메시지 전송 객체는 메시지 수신 객체가 메시지를 처리할 수 있다고 믿고 메시지를 전송.  
      내부 구현에 대한건 알지 못함.
    - 메시지 선언(인터페이스)와 메소드 정의(구현부)의 분리
    - 메시지 전송자는 원하는 메시지를 전송하고, 수신자는 스스로의 판단에 따라 메시지 처리  
      --> 메시지를 기반으로 협력하는 자율적인 객체라는 순수한 객체지향 이상에 가까운 것
    - 하지만, 동적 타입 언어의 이러한 동적인 특성과 유연성은 코드를 이해하고 수정하기 어력게 만들고,  
      디버깅 과정을 복잡하게 만듦
    - 업캐스팅 + 동적 바인딩 + 동적 메소드 탑색
      - 동일한 코드를 이용해 서로 다른 메소드 실행하는 것이 가능해 짐
      - 동일한 메시지에 대해 서로 다른 메소드를 실행할 수 있는 다형성 구현

- self대 super
  - self
    - 동적 메시지 전송
  - super
    - 부모 클래스에게 메시지 "전송"  
      : 이 클래스의 부모 클래스에서부터 메소드 탐색을 시작하라.
    - 자식 클래스에서 부모 클래스의 구현을 재사용
    - 바로 위 부모가 아닌 더 상위에 위치한 조상 클래스의 메소드 호출 가능
    - 부모 클래스 코드에 접근할 수 있게 함으로써 중복 코드를 제거
  - self는 어떤 클래스에게 메시지 탐색이 시작될지 알지 못함. A이거나 B이거나 미래에 추가될 새로운 자식  
    클래스 일 수도 있음
  - super는 항상 해당 클래스의 부모 클래스에서부터 메소드 탐색 시작.  
  - self전송의 메시지 탐색을 시작하는 클래스는 미정이지만, super 전송에서는 미리 정해진다!


##05. 상속 대 위임

- 다형성 : self참조가 가리키는 현재 객체에게 메시지를 전송하는 특성을 기반으로 함  
- 상속 : 자식 클래스에서 부모 클래스로 self 참조를 전달하는 메커니즘

- 위임과 self 참조  
  : 각 계층은 self 참조를 공유한다. (new 된 인스턴스 기준으로 무조건 메시지 전송이 시작된다.)
  - 자신이 수신한 메시지를 다른 객체에게 동일하게 전달해서 처리를 요청하는 것이 "위임"  
    위임은 항상 현재의 실행문맥을 가리키는 self참조를 인자로 전달한다.
    - 요청을 전달받은 최초의 객체에 메시지 전송
  - "포워딩"은 을 하지 않고, 단순히 코드 재사용의 목적으로 사용하며, self 참조를 전달하지 않는다.

- 자바스크립트는 클래스가 존재하지 않지만, 프로토타입으로 연결된 객체들의 체인을 거슬러 올라가며  
  자동적으로 메시지에 대한 위임을 처리한다.
  - 객체들 사이의 메시지 위임만을 위해 "다형성"을 구현한다.  
  --> 객체지향 패러다임에서 클래스는 필수 요소가 아니라는 것을 보여주는 예
  - 클래스 없이 상속과 다형성 구현 가능

> 객체지향은 객체를 지향하는 것  
> 클래스는 객체를 편리하게 정의하고 생성하기 위해 제공되는 프로그래밍 구성 요소일 뿐, 중요한 것은 메시지와 협력.  
> 클래스 없이도 객체 사이의 협력 관계를 구축하는 것이 가능하며 상속 없이도 다형성을 구현하는 것이 가능하다.
