#객체분해
복잡성을 극복하는 방법 >>
- 불필요한 정보를 제거하고 현재의 문제 해결에 필요한 핵심만 남기는 작업 : 추상화
- 큰 문제를 해결 가능한 작은 문제로 나누는 작업 : 분해

- 객체지향 개념 탄생 배경 알아보기.

##01. 프로시저 추상화와 데이터 추상화
- 모든 프로그래밍 패러다임은 추상화와 분해의 관점에서 설명할 수 있다.

1. 프로시저 추상화 : 소프트웨어가 무엇을 해야 하는지를 추상화
2. 데이터 추상화 : 소프트웨어가 무엇을 알아야 하는지 추상화

- 소프트웨어는 데이터를 이용해 정보를 표현하고 프로시저를 이용해 데이터를 조작한다.

- 시스템 분해 방법
  1) 프로시저 추상화 - 기능분해 (Functional decomposition) (==알고리즘 분해)
  2) 데이터 추상화   
     a. 데이터 중심으로 타입을 추상화 (Type abstraction) == 추상 데이터 타입 (Abstract Data Type)   
     b. 데이터 중심으로 프로시저를 추상화 (Procedure abstraction) == 객체지향 (Object-Oriented)

- '역할과 책임을 수행하는 객체'가 객체지향 패러다임이 이용하는 "추상화"
- '협력하는 공동체'를 구성하도록 객체들로 나누는 과정이 객체지향 패러다임의 "분해"

- 프로그래밍 언어 관점에서 객체지향?   
  데이터를 중심으로 데이터 추상화와 프로시저 추상화를 통합한 객체를 이용해 시스템을 분해하는 방법

##02. 프로시저 추상화와 기능 분해
- 추상화 단위 : 프로시저
- 전통적인 기능 분해 방법은 하향식 접근법을 따른다. (top-down)
- 정제된 기능은 자신의 바로 상위 기능보다 덜 추상적 이어야 한다.
- 메인 함수를 루트로 하는 트리구조

**하향식 기능 분해의 문제점**
- 설계가 필요한 이유? 변경에 대비하기 위함
- 하양식 기능 분해는 변경에 취향한 설계를 낳는다.
  1) 기능 추가, 요구사항 변경 시 메인 함수를 빈번하게 수정
  2) 비즈니스 로직이 사용자 인터페이스와 강하게 결합
  3) 하향식 분해는 함수들의 실행 순서를 고정시켜 유연성과 재사용성이 저하됨
  
- 하향식 설계 문제의 원인 : 결합도   
  함수는 상위 함수가 강요하는 문맥, 절차를 구성하는 함수들과 시간적으로 강하게 결합돼 있다.   
  강하게 결합된 시스템은 아주 사소한 변경만으로도 전체 시스템을 변경시키기도 한다. (재사용 어려움)

- 현대적인 시스템은 동등한 수준의 다양한 기능으로 구성된다. (메인이 top인 구조 No!)
> 객체지향은 함수간의 호출 순서가 아니라, 객체 사이의 논리적인 관계를 중심으로 설계를 이끌어 나간다.
> 어떤 한 구성요로(main)로 제어가 집중되지 않고 여러 객체들 사이로 제어 주체가 분산된다.
 
- 의존성 관리   
  변경에 대한 영향을 최소화 하기위해 영향 받는 부분/ 받지 않는 부분을 분리하고   
  퍼블릭 인터페이스를 통해 변경되는 부분에 대한 접근을 통제하라.
- 기능분해가 가진 문제를 해결하기 위해 이 같은 개념을 기반으로 한 "정보은닉"과 "모듈"이라는 개념이 제시되었다.

**하향식 분해가 유용한 경우**
- 이미 완전히 이해된 사실을 서술할 때 적합하다.   
  새로운 것을 개발하고 설계하고, 발견하는 데 적합하지 않다.
- 작은 프로그램과 개별 알고리즘을 위해서는 유용한 패러다임
- 이미 해결한 알고리즘을 문서화 하고 서술하는데 훌륭한 기법

##03. 모듈
**정보 은닉과 모듈**
- 정보은닉은 시스템을 모듈 단위로 분해하기 위한 기본 원리
- 시스템에서 자주 변경되는 부분을 상대적으로 덜 변경되는 안정적인 인터페이스 뒤로 감추는게 핵심
- 정보은닉은 외부에 감춰야 하는 비밀에 따라 시스템을 분할하는 모듈 분할 원리
- 비밀이 반드시 데이터일 필요는 없으며 복잡한 로직이나 변경 가능성이 큰 자료구조 일 수 있다.   
  (데이터 캡슐화와 정보 은닉을 혼동하지 말자)
- 자바에서 모듈의 개념은 패키지를 이용해 주현 (public, private)

**모듈의 장점, 한계**
- 모듈은 기능이 아니라 변경의 정도에 따라 시스템을 분해하게 한다.
- 모듈은 외부에 감춰야 하는 비밀과 관련성 높은 데이터와 함수의 집합
- 모듈 내부는 높은 응집도를 유지
- 모듈과 모듈 사이에는 퍼블릭 인터페이스를 통해서만 통신하므로 낮은 결합도를 유지
- 단, 변경을 관리하기 위한 구현 기법이므로 추상화 관점에서의 한계점이 있다.
- 이를 만족시키기 위해 등장한 개념이 "추상 데이터 타입"

##04. 데이터 추상화와 추상 데이터 타입
**추상 데이터 타입**
- 프로그래밍 언어에서 타입(Type)   
  변수에 저장할 수 있는 내용물의 종류, 변수에 적용될 수 있는 연산의 가짓수를 의미
- 기능 분해 시대의 프로그래밍 언어는 내장 타입만 제공하고, 새로운 타입 추가가 불가능 or 제한적
- 이 시대 프로그램에서 사용하는 주된 추상화는 "프로시저 추상화"
- "추상 데이터 타입"은 프로시저 추상화 대신 데이터 추상화를 기반으로 소프트웨어를 개발하게 한 최초의 발걸음
- 추상 데이터 타입 구현을 하려면?   
  1) 타입 정의를 선언할 수 있어야 한다
  2) 타입의 인스턴스를 다루기 위해 사용할 오퍼레이션의 집합을 정의할 수 있어야 한다
  3) 제공된 오퍼레이션을 통해서만 조작할 수 있고, 데이터를 외부로부터 보호해야 한다
  4) 타입에 대해 여러 인스턴스를 생성할 수 있어야 한다
- 추상 데이터 타입의 기본 의도는, 프로그래밍 언어가 제공하는 타입처럼 동작하는 사용자 정의 타입을   
  추가할 수 있게 하는 것.
- 프로그래밍 언어의 관점에서 추상 데이터 타입은 내장 데이터 타입과 동일하다.
- 그러면, 클래스는 추상 데이터 타입인가?

##05. 클래스
**클래스는 추상 데이터 타입인가?**
- 결론: 동일하지 않다.
- 클래스는 상속과 다형성을 지원하지만, 추상 데이터 타입은 지원하지 못한다.
- 추상 데이터 타입은 타입을 추상화(type abstraction) 한 것 이고   
  클래스는 절차를 추상화(Procedural abstraction) 한 것 이다.
- 추상데이터 타입은 오퍼레이션을 기준으로 타입을 묶는다.   
  Employee라는 타입이 있을 때, calculatePay()와 같은 오퍼레이션 호출은 가능하나,   
  정규 직원, 아르바이트 직원이 있다는 사실을 알 수 없다.
- 객체지향은 타입을 기준으로 오퍼레이션을 묶는다.   
  정규직원과 아르바이트 직원이라는 두 개의 타입을 명시적으로 정의하고 (클래스로 각각 정의)   
  두 직원 유형과 관련된 오퍼레이션의 실행 절차를 두 타입에 분배한다.   
  (각각 클래스에서 calculatePay() 오퍼레이션 구현)
- 보통, 두 클래스 정의 후 공통 로직을 포함하는 부모클래스를 정의하는데,   
  클라이언트가 메시지를 전송하면 실제 클래스가 무엇인가에 따라 적절한 "절차"가 실행된다.    
  --> 동일한 메시지에 다르게 반응하는 것 (다형성)
- 실제 내부에서 수행되는 절차는 다르지만, 클래스를 이용한 다형성은 절차에 대한 차이점을 감춘다.
- 객체지향은 "절차 추상화"

**변경을 기준으로 선택하라**
- 추상 데이터 타입은 유형을 저장하여 저장된 값을 기반으로 메소드에서 분기처리를 한다.
- 객체지향에서는 타입 변수를 이용한 조건문을 다형성으로 대체한다.
- 클라이언트가 객체의 타입을 확인 한 후, 적절한 메소드를 호출하는게 아니라   
  객체가 메시지를 처리할 적절한 메소드를 선택한다.
- 조건문을 사용하는 방식을 기피하는 이유 : 변경
- 객체지향으은 새로운 직원유형 추가시, 기존 코드는 수정하지 않고 Employee를 상속받는    
  새로운 직원유형을 추가하면 된다.   
  --> 개방-폐쇄 원칙 (객체지향은 변경과 확장이 용이함)
- 그렇다고 추상데이터 타입이 나쁜것은 아니다!!
- 오퍼레이션 추가가 잦은 경우엔, 추상데이터 타입을   
  새로운 타입 추가가 잦다면 객체지향을 선택할 수 있다.
- 모듈과 추상 데이터 타입 : 데이터 중심적인 관점   
  객체지향 : 서비스 중심적인 관점
  
**협력이 중요하다**
- 객체지향에서 중요한 것은 역할, 책임, 협력
- 객체가 참여할 협력을 결정하고 협력에 필요한 책임을 수행하기 위해 어떤 객체가 필요한지에 관해 고민하라.
- 그 책임을 다양한 방식으로 수행해야 할 때만 타입 계층 안에 각 절차를 추상화 하라. 
- 타입 계층과 다형성은 협력이라는 문맥 안에서 책임을 수행하는 방법에 관해 고민한 결과물이어야 한다.