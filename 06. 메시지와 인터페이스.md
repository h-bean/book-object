#메시지와 인터페이스

1.객체지향 프로그래밍에 대한 가장 흔한 오해는 애플리케이션이 클래스의 집합으로 구성된다는 것
 - 클래스는 구현 도구일 뿐이다.

2.클래스 사이의 정적인 관계에서 메시지 사이의 동적인 흐름으로 초점을 전환하자

##01. 협력과 메시지
**클라이언트 - 서버 모델**
- 협력은 클라이언트가 서버의 서비스를 요청하는 단방향 상호작용
- 협력 안에서 메시지를 전송하는 객체를 클라이언트, 메시지를 수신하는 객체를 서버
- 객체는 협력에 참여하는 동안 클라이언트와 서버의 역할을 동시에 수행

**메시지와 메시지 전송**
- 메시지   
  : 오퍼레이션명 + 인자
- 메시지 전송
  : 메시지 + 메시지 수신자   
  (EX. condition.isSatisfiedBy(screening) / 수신자.오퍼레이션명(인자))

**메시지와 메소드**
- 객체는 메시지와 메소드라는 두 가지 서로 다른 개념을 실행 시점에 연결해야 한다.
- 컴파일 시점과 실행 시점의 의미가 달라질 수 있음
- 메시지와 메소드의 구분은 메시지 전송자와 메시지 수신자가 느슨하게   
  결합될 수 있게 한다.
- 메시지 수신자는 메시지를 처리하기 위해 필요한 메소드를 스스로 결정할 수 있는   
  자율권을 누린다.
- 실행 시점에 메시지와 메소드를 바인딩하는 메커니즘은 두 객체 사이의 결합도를   
  낮춤으로써 유연하고 확장 가능한 코드를 작성할 수 있게 만든다.

**퍼블릭 인터페이스와 오퍼레이션**   
1.퍼블릭 인터페이스
 - 객체가 의사소통을 위해 외부에 공개하는 메시지의 집합

2.오퍼레이션
 - 퍼블릭 인터페이스에 포함된 메시지 각각   
 - 오퍼레이션은 수행 가능한 어떤 행동에 대한 추상화

3.메소드
 - 메시지를 수신했을 때 실제로 실행되는 코드
 - 오퍼레이션에 대한 구현

> 객체가 다른 객체에게 메시지를 전송하면 런타임 시스템은 메시지 전송을 오퍼레이션 호출로 해석하고 메시지를 수신한
> 객체의 실제 타입을 기반으로 적절한 메소드를 찾아 실행한다.

4.메시지
 - 객체가 다른 객체와 협력하기 위해 사용하는 의사소통 메커니즘
 - 객체의 오퍼레이션이 실행되도록 요청하는 것이 메시지 전송

5.시그니처
 - 오퍼레이션(혹은 메소드)의 이름과 파라미터 목록
 - 대부분 반환타입은 시그니처로 포함하지 않지만, 포함하는 언어도 있다.

> 다형성의 축복을 받기 위해서는 하나의 오퍼레이션에 대해 다양한 메소드를 구현해야 한다.
> 따라서 오퍼레이션의 관점에서 다형성이란 동일한 오퍼레이션 호출에 대해 서로 다른 메소드들이 실행되는 것.

##02. 인터페이스와 설계 품질
책임주도 설계를 하라
1.메시지를 먼저 선택함
 - 협력과 무관한 오퍼레이션이 인터페이스에 포함되는 것을 방지
 - "최소한의 인터페이스" : 꼭 필요한 오퍼레이션만 인터이스에 포함
 
2.객체가 메시지를 선택하지 않고, 메시지가 객체를 선택함
 - "추상적인 인터페이스" : 어떻게 수행하는지가 아니라 무엇을 하는지 표현

퍼블릭 인터페이스 품질에 영향을 미치는 원칙 >>   
**디미터 법칙 (Law of Demeter)**   
1. 협력하는 객체 내부 구조에 대한 결합으로 인해 발생하는 설계 문제를 해결하기 위해 제안된 원칙   
2. 객체 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한
3. 디미터의 법칙은 협력하는 클래스의 캡슐활르 지키기 위해 접근해야 하는 요소를 제한한다.
4. 훌륭한 메시지는 객체의 상태에 관해 묻지 않고, 원하는 것을 시켜야 한다는 사실을 강조

> 클래스 내부의 메소드가 아래 조건을 만족하는 인스턴스에만 메시지 송신 가능
> - this객체
> - 메소드의 매개변수
> - this의 속성
> - this의 속성인 컬렉션의 요소
> - 메소드 내에서 생성된 지역객체

EX) screening.getMovie().getDiscountConditions();  : 이런 기차충돌 코드 사용하지 않기!

**묻지말고 시켜라**
1. 메시지 전송자는 수신자의 상태를 기반으로 결정을 내린 후, 수신자의 상태를 바꾸면 안된다.
2. 구현하는 로직은 메시지 수신자가 담당해야 할 책임
3. 객체 외부에서 해당 객체의 상태를 기반으로 결정을 내리는 것은 객체의 캡슐화를 위반한다.   
   : 객체가 책임져야 할 행동이 외부로 누수된 것!!!
4. 묻지말고 시켜라 원칙을 따르도록 메시지를 결정하면, 자연스럽게 "정보전문가"에게 책임을 할당하게 되고
   "높은 응집도"를 가진 클래스를 얻을 확률이 높아진다.
5. 시켜라 원칙과 디미터 법칙은 퍼블릭 인터페이스의 품질을 향상시키는 좋은 습관이다.

> 절차적인 코드는 정보를 얻은 후에 결정한다. 객체지향 코드는 객체에게 그것을 하도록 시킨다.

**의도를 드러내는 인터페이스**
1. 
 
 메소드 수준에서 캡슐화를 위반   
   : 책임을 수행하는 방법을 드러내는 메소드를 사용한 설계는 변경에 취약

2. 방법 2 ) '어떻게'가 아니라 '무엇'을 하는지 드러낸다   
   : 클라이언트의 관점에서 협력을 바라보고, 추상적인 이름을 붙여라   
   : 의도를 드러내는 선택자 패턴

3. 의도를 드러내는 인터페이스   
   : 구현과 관련된 모든 정보를 캡슐화 하고, 객체의 퍼블릭 인터페이스에는   
   협력과 관련된 의도만을 표현해야 한다.

> 객체에게 묻지 말고 시키되 구현 방법이 아닌 클라이언트의 의도를 드러내야 한다.

##03. 원칙의 함정
- 설계는 트레이드오프의 산물이므로, 원칙이 현재 상황에 부적합하다고 판단된다면 과감하게 원칙을 무시하라.

**디미터 법칙은 하나의 도트(.)를 강제하는 규칙이 아니다**
- 여러 개의 도트를 사용한 코드가 객체의 내부 구조를 노출하는지를 판단하라.
- 자바8의 IntStream은 도트를 여러 개 사용하나 내부구조를 노출하지 않는다.   
  EX) IntStream.of(1, 15, 20, 3, 9).filter(x -> x > 10).distinct().count();
- 위의 각 메소드는 동일안 IntStream 인스턴스를 반환하고, 결합도가 문제되지 않는다.

**결합도와 응집도의 충돌**
- "묻지말고 시켜라" 원칙에 따라 맹목적으로 위임 메소드를 추가하면 한 객체가 상관 없는 책임들을 떠안게 될 수 있다.
- 클래스는 하나의 변경 원인만을 가져야 한다.
- 서로 상관없는 책임들이 함께 뭉쳐있는 클래스는 응집도가 낮으며 작은 변경으로도 쉽게 무너질 수 있다.
- 객체에게 시키는 것이 항상 가능한 것은 아니다. 가끔씩은 물어야 한다.
- 디미터 원칙 위반 여부는 묻는 대상이 객체인지, 자료 구조인지에 달려있다. (클린코드)

##04. 명령-쿼리 분리 원칙
- 프로시저 : 정해진 절차에 따라 내부의 상태를 변경하는 루틴의 한 종류   
  부수효과를 발생 시키나, 값을 반환할 수 없다. (명령)
- 함수 : 어떤 절차에 따라 필요한 값을 계산해서 반환하는 루틴의 한 종류   
  값을 반환 하나, 부수효과를 발생시킬 수 없다. (쿼리)
- 어떤 오퍼레이션도 명령인 동시에 쿼리여서는 안된다.
- 명령 쿼리 분리 원칙에 따라 작성된 객체의 인터페이스를 명령-쿼리 인터페이스 라고 한다.

**명령과 쿼리를 분리해서 얻는 장점**
- 퍼블릭 인터페이스를 설계할 때 부수효과를 가지는 대신 값을 반환하지 않는 명령과, 부수효과를    
  가지지 않는 대신  값을 반환하는 쿼리를 분리하라   
  --> 코드는 예측 가능하고 이해하기 쉬우며 디버깅이 용이한 동시에 유지보수가 수월해 질 것.

**명령-쿼리 분리와 참조 투명성**
- 쿼리는 객체의 상태를 변경하지 않기 때문에 몇 번이고 반복적으로 호출해도 상관 없다.
- 명령과 쿼리의 분리는 명령형 언어의 틀 안에서 참조 투명성의 장점을 제한적이나마 누릴 수 있다.
- 참조투명성? 어떤 표현식 e가 있을 때 모든 e를 e의 값으로 바꾸더라도 결과가 달라지지 않는 특성   
  수학에서 함수는 동일한 입력에 항상 동일한 값을 반환하므로 참조 투명성을 지키는 이상적인 예   
  --> 수학에서의 함수는 부수효과가 발생하지 않는다.
- 명령-쿼리 분리 원칙은 부수효과를 가지는 명령으로부터 부수효과를 가지지 않는 쿼리를 분리함으로써   
  제한적이나마 참조 투명성의 혜택을 누릴 수 있게 된다.

**책임에 초점을 맞춰라**
- 디미터 법칙 : 협력이라는 컨텍스트 안에서 객체보다 메시지를 먼저 결정하면 두 객체 사이의 구조적   
  결합도를 낮출 수 있다.
- 묻지 말고 시켜라 : 메시지를 먼저 선택하면 묻지 말고 시켜라 스타일에 따라 협력을 구조화하게 된다.
- 의도를 드러내는 인터페이스 : 메시지를 먼저 선택한다는 것은 메시지를 전송하는 클라이언트의 관점에서   
  메시지를 정하는 것이라, 이름에 클라이언트 의도가 분명히 드러난다.
- 명령-쿼리 분리 원칙 : 메시지를 먼저 선택한다는 것은 협력이라는 문맥 안에서 객체의 인터페이스에 관해   
  고민한다는 것을 의미한다. 예측가능한 협력을 만들기 위해 명령과 쿼리를 분리하게 될 것이다.

- 책임 주도 설계 : 객체가 메시지를 이 아닌! 메시지가 객체를 선택하게 하여 
  협력에 적합한 메시지를 결정할 수 있는 확률이 높아진다.