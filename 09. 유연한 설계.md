# 유연한 설계
- 8장의 의존성 기법들을 "원칙"관점으로 정리하는 장

## 01. 개방-폐쇄 원칙 (Open-Closed Principle, OCP)
- 소프트웨어 개체(클래스, 모듈, 함수 등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.
- 확장 -> 동작 / 수정 -> 코드
- 유연한 설계란 기존의 코드를 수정하기 않고 애플리케이션 동작을 확장할 수 있는 설계
- 개방-폐쇄 원칙은 런타입 의존성과 컴파일 의존성 이야기   
  ![KakaoTalk_20210906_192645413](https://user-images.githubusercontent.com/67268117/132206424-71b26dba-57d6-45ab-af4e-0db09830b394.jpg)
- 컴파일타임 의존성은 고정시키고, 런타임 의존성을 변경해야 한다.
- 새로운 할인정책 추가 시, 기존 소스코드는 변경하지 않고 동작을 추가(확장)할 수 있다.
- 개방-폐쇄 원칙을 수용하는 코드는 컴파일타임 의존성을 수정하지 않고, 런타임 의존성을 쉽게 변경할 수 있다.
- 결론) 의존성 관점에서 개방-폐쇄 원칙을 따르는 설계란 ?   
  컴파일타임 의존성은 유지하며, 런타임 의존성의 가능성을 확장하고 수정할 수 있는 구조 ✔
  ![KakaoTalk_20210906_195627680](https://user-images.githubusercontent.com/67268117/132206993-54f19dcc-6d06-4efa-b3cb-ced620c865ca.jpg)

**추상화가 핵심이다**
- 개방-폐쇄 원칙의 핵심은 "추상화"에 "의존"하는 것
- 추상화 : 핵심적인 부분만 남기고 불필요한 부분은 생략함으로써 복잡성을 극복하는 기법
- 개방-폐쇄 원칙의 생략되지 않고 남겨지는 부분은 다양한 상황에서의 공통점을 반영한 추상화의 결과물
- 공통적인 부분은 문맥이 바뀌어도 변하지 않아야 한다. (수정할 필요가 없어야 함)
- 추상화 부분은 수정에 대해 닫혀 있다.
- 추상화를 통해 생략된 부분은 확장의 여지를 남긴다.   
  EX) DiscountPolicy의 할인여부 판단 로직은 변하지 않는 부분 / 할인된 요금 계산 방법은 변하는 부분   
  DiscountPolicy는 추상화이며, 상속을 통해 생략된 부분을 구체화 함으로써 할인정책을 확장한다.
- 올바른 추상화를 설계하고 추상화에 대해서만 의존하도록 관계를 제한하면 설계를 유연하게 확장할 수 있다.

## 02. 생성 사용 분리
- Movie가 DiscountPolicy(추상화)에만 의존하기 위해서는 Movie내에서 구체클래스의 인스턴스를 생성하면 안된다.
  (동작 추가/변경시 컴파일타임 코드가 수정되므로 개방-폐쇄 원칙 위반)
- 객체 생성에 대한 지식은 과도한 결합도를 초래한다.
- 객체 생성자체가 문제가 아니라, 적절한 곳에서 생성을 해야 한다.
- 소프트웨어 시스템은 (응용 프로그램 객체를 제작하고 의존성을 서로 "연결"하는) 시작 단계와   
  (시작 단계 이후에 이어지는) 실행 단계를 분리해야 한다. ✔   
  즉, 생성과 사용을 분리해야 한다.   
  ![KakaoTalk_20210906_201516130](https://user-images.githubusercontent.com/67268117/132209202-f5336cbc-89ae-4893-86ed-50f293976024.jpg)
  ![KakaoTalk_20210906_201533516](https://user-images.githubusercontent.com/67268117/132209204-fd883d0d-010a-49dd-a112-a6bc4595d440.jpg)
- 위의 예 처럼 Movie와 협력할 클라이언트로 컨텍스트에 대한 지식을 옮기자. (생성 분리)
- Movie는 특정 클라이언트에 결합되지 않고 독립적이게 된다. (사용만 함)

**FACTORY 추가하기**
- FACTORY는 생성과 사용을 분리하기 위해 객체 생성에 특화된 객체 ✔
- Client도 특정한 컨텍스트에 묶이지 않게 하려면?   
  단, 객체 생성지식을 Client와 협력하는 다른 클라이언트에 새어나가길 원하지 않는다면?   
  ![KakaoTalk_20210906_204425413](https://user-images.githubusercontent.com/67268117/132212523-d8bacdd9-d398-40b6-917e-2c55aeb45d11.jpg)
- 객체 생성과 관련된 책임만 전담하는 별도의 객체를 추가하고 Client가 객체를 사용하게 한다. (FACTORY)

**순수한 가공물에 책임 할당하기**
- 책임할당원칙 패턴(GRASP 패턴)은 책임을 수행하는데 필요한 정보를 가장 많이 아는   
  INFOMATION EXPERT를 도메인 모델 안에서 찾는 것이다.
- FACTORY는 결합도를 낮추고 재사용성을 높이기 위해 도메인 개념에게 할당돼 있던 객체 생성 책임을   
  도메인 개념과 전혀 상관이 없는 가공의 객체로 이동시킨 것이다.
- 모든 책임을 도메인 객체에 할당하면 낮은 응집도, 높은 결합도, 재사용성 저하 등 문제점에 봉착할 수 있다.
- 이 경우 설계자가 편의를 위해 임의로 만들어낸 가공의 객체에게 책임을 할당하여 문제를 해결한다.
- 책임 할당을 위해 창조되는, 도메인과 무관한 인공적인 객체를 PURE FABRICATION(순수한 가공물)이라 한다.
> 이런 측면에서 객체지향이 실세계의 모방이라는 말은 옳지 않다.   
> 객체지향 애플리케이션의 대부분은 실제 도메인에서 발견할 수 없는 순수한 인공물로 가득 차 있다.   
> 도메인 개념을 표현하는 객체와 순수하게 창조된 가공의 객체들이 모여, 자신의 역할과 책임을 다 하고   
> 조화롭게 협력하는 애플리케이션을 설계하는 것이 목표여야 한다.

## 03. 의존성 주입
- Movie에 오로지 인스턴스 사용 책임만 남기려면?   
  외부의 다른 객체가 Movie에게 생성된 인스턴스를 전달해야 한다.
- 사용하는 객체가 아닌 외부의 객체가 인스턴스를 생성한 후 이를 전달해서 의존성을 해결하는 방법  
  : 의존성 주입 (Dependency Injection)
- 생성자 주입, setter 주입, 메소드 주입 (의존성 해결방법과 관련이 있다.)
- 필요한 의존성은 클래스의 퍼블릭 인터페이스에 명시적으로 드러나야 한다.   
  숨겨진 의존성을 사용하지 말자 (ex. SERVICE LOCATOR 패턴)
- 캡슐화 관점에서 훌륭한 코드는 클래스의 퍼블릭 인터페이스만으로 사용방법을 이해할 수 있는 코드   
  SERVICE LOCATOR는 클래스 사용법을 익히기 위해 구현 내부는 뒤져야 한다. (캡슐화 위반)
  
## 04. 의존성 역전 원칙
**추상화와 의존성 역전**
- 유연하고 재사용 가능한 설계를 원한다면 모든 의존성의 방향이 추상 클래스나 인터페이스와 같은 추상화를 따라야 한다.
- 구체클래스는 의존성의 시작점이어야 한다.
> 의존성 역전 원칙   
> 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안된다. 둘 모두 추상화에 의존해야 한다.   
> 추상화는 구체적인 사항에 의존해서는 안된다. 구체적인 사항은 추상화에 의존해야 한다.
- 잘 설계된 객체지향 프로그램의 의존성 구조는 전통적인 절차적 방법에 의해   
  일반적으로 만들어진 의존성 구조에 대해 '역전'된 것이다.

**의존성 역전 원칙과 패키지**
- 전통적인 모듈 구조는 인터페이스 소유권을 클라이언트 모듈이 아닌 서버 모듈에 위치시킨다.
![KakaoTalk_20210906_215625033](https://user-images.githubusercontent.com/67268117/132221069-089bfd86-2372-46bd-b8f8-991246ced646.jpg)
  - 문제점 : Movie를 재사용하기 위해서는 DiscountPolicy 클래스가 필요한데,   
    DiscountPolicy에 의존하기 위해서는 같은 패키지에 있는 구체클래스들도 함께 존재해야 한다.  
    불필요한 클래스들이 Movie와 함께 배포되는 것.

- 잘 설계된 객체지향 애플리케이션에서는 인터페이스 소유권을 서버가 아닌 클라이언트에 위치시킨다.
![KakaoTalk_20210906_215648842](https://user-images.githubusercontent.com/67268117/132221156-892efa08-963a-4c35-b7c6-639a4b556a74.jpg)
  - Movie를 다른 컨텍스트에서 재사용 하기 위해서는 Movie와 DiscountPolicy가 포함된 패키지만   
    재사용 하면 된다.
> 훌륭한 객체지향 설계를 위해서는 의존성을 역전시켜야 한다.
> - 유연하고 재사용 가능하며 컨텍스트에 독립적인 설계는 전통적인 패러다임이 고수하는 의존성의 방향을 역전시킨다.
> - 전통적인 패러다임에서는 상위 수준 모듈이 하위 수준 모듈에 의존했다면 객체지향 패러다임에서는 상위 수준 모듈과
>   하위 수준 모듈이 모두 추상화에 의존한다.
> - 전통적인 패러다임에서는 인터페이스가 하위 수준 모듈에 속했다면, 객체지향 패러다임에서는 인터페이스가 상위수준
>   모듈에 속한다.