# 타입 계층의 구현

- 타입과 클래스는 다르다.
  - 타입 : 개념의 분류를 의미
  - 클래스 : 타입을 구현하는 한 가지 방법

- 타입 계층은 동일한 메시지에 대한 행동 호환성을 전제로 하기 때문에, 아래 나오는 모든 방법은  
  타입 계층을 구현하는 방법인 동시에 다형성을 구현하는 방법이다.

타입과 타입 계층을 구현하는 다양한 방법들 살펴보기 >
--

1.클래스를 이용한 타입 계층 구현
- 클래스 : 사용자 정의 "타입" (User-defined data type)
  - 타입은 객체의 퍼블릭 인터페이스를 가리킴
  - 클래스는 타입과 구현을 동시에 정의하는 것과 같다.
- 상속을 이용하면 자식 클래스가 부모 클래스의 구현 + 퍼블릭 인터페이스를 물려받을 수 있기 때문에  
  쉽게 타입 계층을 구현할 수 있다.
  - 단, 상속은 자식과 부모 클래스를 강하게 결합시키기 때문에 구체 클래스를 상속받는 것은 피해야 한다.
  - 인터페이스를 구현하거나 추상 클래스를 상속받자.
- 클래스는 타입을 구현할 수 있는 다양한 방법 중 하나 일 뿐!


2.인터페이스를 이용한 타입 계층 구현
- 인터페이스가 다른 인터페이스를 확장하도록 만들면 슈퍼타입과 서브타입간의 타입 계층을 구성할 수 있다.
- 인터페이스를 이용해 타입의 퍼블릭 인터페이스를 정의하고 클래스를 이용해 객체를 구현하는 것이 일반적인 패턴.
- 인터페이스를 이용하면?
  - 여러 클래스가 동일한 타입을 구현할 수 있다.
  - 하나의 클래스가 여러 타입을 구현할 수 있다.
- 인터페이스를 이용해 타입을 정의하고 클래스를 이용해 객체를 구현하면 클래스 상속을 사용하지 않고 타입계층을 구현할 수 있다.

- 객체의 "클래스"
  - 객체의 구현을 정의
  - 객체 내부 상태와 오퍼레이션 구현 방법을 정의

- 객체의 "타입"
  - 인터페이스만을 정의
  - 객체가 반응할 수 있는 오퍼레이션의 집합

- 클래스와 타입의 차이점을 이해하는 것은 설계 관점에서 매우 중요
  - 타입 : 동일한 퍼블릭 인터페이스를 가진 객체들의 범주
  - 클래스 : 타입에 속하는 객체들을 구현하기 위한 구현 메커니즘
  
- 객체지향에서 중요한 것은 협력 안에서 객체가 제공하는 "행동"  
  --> 타입이 중요하다
  - 타입이 식별 된 후, 타입에 속하는 객체를 구현하기 위해 클래스를 사용하는 것.

- 중요한 것은 객체가 외부에 제공하는 행동, 즉 타입을 중심으로 객체들의 계층을 설계하는 것.


3.추상 클래스를 이용한 타입 계층 구현
- 클래스 상속을 이용해 구현을 공유하면서도 결합도로 인한 부작용을 피하는 방법 = 추상 클래스 상속
- 구체 클래스 상속 vs 추상 클래스 상속 차이?
  - 의존하는 대상의 추상화 정도가 다르다.
    - 구체 클래스를 상속하면 부모의 내부 구현에 강하게 결합되어, 부모 클래스 변경 시  
      자식 클래스도 함께 변경될 가능성이 높다.
    - 추상 클래스를 상속하면 자식 클래스는 온전히 "추상 메소드의 시그니처에만 의존"한다.
    - 추상 메소드로 정의된 메소드만 오버라이딩 하면 된다는 사실에만 의존해도 무방하다.
    - 구체적인 메소드가 추상적인 메소드에 의존하기 때문에 의존성 역전 원칙을 따른다.  
      이 설계는 유연한 동시에 변화에 안정적이다.
    - 의존하는 대상이 더 추상적일수록 결합도는 낮아지고 결합도가 낮아질수록 변경으로 인한 영향도  
      줄어든다. (모든 구체클래스의 부모클래스를 항상 추상 클래스로 만들기 위해 노력하라) ✔
  - 상속을 사용하는 의도가 다르다.
    - 구체클래스를 상속받는 설계는 코드 재사용을 위해 상속을 사용하는 것이다.  
      (추후 자식 클래스가 생길걸 염두하지 못한 설계)
    - 추상클래스의 유일한 목적은 자식클래스를 추가하는 것
    - 추상 메소드를 제공함으로써 상속 계층을 쉽게 확장할수 있게 하고 결합도로 인한 부작용을  
      방지할 수 있는 안전망을 제공한다.

4.추상 클래스와 인터페이스 결합하기
- 다중 상속이 필요 한 경우, 인터페이스를 이용해 확장할 수 있다.
- 단, 인터페이스는 구현 코드는 포함할 수 없어 중복 코드를 제거하기 어렵다. (자바 8 이전)
- 추상 클래스와 인터페이스를 함께 사용할 수 있는데, 이를 "골격 구현 추상 클래스"라 한다.  
  ![골격 구현 추상클래스](https://user-images.githubusercontent.com/98109708/154081733-14e425d7-a29d-4df4-a722-2cef2c59a3d4.jpg)
  - 최상위 타입을 인터페이스로 변경하고, 공통 코드를 담을 골격 구현 추상클래스를 추가한다.
  - 장점1. 다양한 구현 방법이 필요할 경우 새로운 추상 클래스를 추가해서 쉽게 해결 가능
  - 장점2. 이미 부모 클래스가 존재하는 클래스도 인터페이스를 추가함으로써 새로운 타입으로 확장 가능  
    만약, DiscountPolicy가 추상클래스 였다면? 이 문제를 해결할 수 있는 유일한 방법은 상속 계층을  
    다시 조절하는 것 뿐 !!!
- 설계가 상속 계층에 얽매이지 않는 타입 계층을 요구한다면 인터페이스로 타입을 정의하자. ✔
  - 추상 클래스로 기본 구현을 제공해서 중복 코드를 제거하자.
 
5.덕 타이핑 사용하기
- 동적 타입 언어에 사용하는 방법 (자바는 정적 타입 언어!)
- 덕 테스트(duck test)를 프로그래밍 언어에 적용한 것  
  덕 테스트는 "행동"이 오리와 같다면 그것을 오리라는 타입으로 취급해도 무방하다는 것.
  - 객체가 어떤 인터페이스에 정의된 행동을 수행할 수 있다면, 그 객체를 해당 타입으로 분류해도 문제가 없다.
- 자바에서는 extends, implements 키워드를 통해 명시해야 동일한 타입으로 취급하지만,  
  동적 타입 언어에서는 명시적으로 동일한 클래스를 상속받거나 동일한 인터페이스를 구현하지 않더라도  
  시그니처가 동일한 메소드를 가진 클래스는 같은 타입으로 취급할 수 있다.
- 객체지향 설계의 목표는 코드 수정 비용을 줄이는 것 ✔  
  유연한 설계의 한 가지 조건 = 컨텍스트 독립성
  - 인터페이스가 클래스보다 더 유연한 설계를 가능하게 해주는 이유는 클래스가 정의하는 "구현" 이라는  
    컨텍스트에 독립적인 코드를 작성할 수 있게 해주기 때문
  - 덕 타이핑은 더 나아가 메소드 시그니처만 동일하면 "명시적인 타입 선언"이라는 컨텍스트를 제거할 수 있다.
  - 덕 타이핑은 클래스나 인터페이스에 대한 의존성을 메시지에 대한 의존성으로 대체한다.
  - 덕 타이핑은 클래스나 인터페이스 수준의 결합도를 메시지 수중의 결합도로 낮춘다.
- 하지만 덕 타이핑은 컴파일 시점에 발견할 수 있는 오류를 실행 시점으로 미룬다.  
  설계의 유연성은 높아지고, 코드의 안전성은 약화됨
- 프로그래밍 언어도 설계처럼 트레이드오프의 산물이다 ~

6.믹스인과 타입 계층
- 믹스인(mixin)은 객체를 생성할 때 코드 일부를 섞어 넣을 수 있도록 만들어진 일종의 추상 서브클래스다.
- 믹스인의 목적은?  
  다양한 객체 구현 안에서 동일한 "행동"을 중복코드 없이 재사용할 수 있게 만드는 것.
- 자바는 디폴트 메소드로 믹스인을 구현할 수 있다.
  - 디폴트 메소드는 인터페이스에 메소드의 기본 구현을 추가하는 것을 허용한다.
  - 디폴트 메소드를 사용하면 추상 클래스가 제공하는 코드 재사용성이라는 혜택을 그대로 누리며,  
    특정한 상속 계층에 얽매이지 않는 인터페이스의 장점을 유지할 수 있다.
  - 디폴트 메소드를 이용하면 기본 구현을 제공하기 위해 인터페이스를 구현하는 추상 클래스를  
    만들 필요가 없다.
  - 하지만 "골격 구현 추상 클래스"와 다르게 인터페이스를 구현하는 모든 클래스들이 디폴트 구현에 사용된
    메소드들을 모두 제공해야 한다는 것을 명시한다.
    - 이러한 디폴트 메소드 사용은 인터페이스가 불필요하게 비대해지고 캡슐화가 약화될 수 있다.
    - 자바8에서 디폴트 메소드 추가 목적은 인터페이스로 추상 클래스 역할을 대체하려는 것이 아니기 때문!
  - 디폴트 메소드는 기존에 사용되고 있는 인터페이스에 새로운 오퍼레이션을 추가할 경우에 발생하는  
    하위 호환성 문제를 해결하기 위함!

> 결론 및 주의사항  
> 다양한 방식으로 타입 계층을 구현할 수 있다.  
> 그러나 여기서 사용된 방법을 사용해 타입 계층을 구현한다고 해도, 리스코프 치환 원칙을  
> 준수하지 않는다면 올바른 타입 계층을 구현한 것이 아니다.
    